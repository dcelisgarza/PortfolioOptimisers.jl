<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Example 4: Pareto surface · PortfolioOptimisers.jl</title><meta name="title" content="Example 4: Pareto surface · PortfolioOptimisers.jl"/><meta property="og:title" content="Example 4: Pareto surface · PortfolioOptimisers.jl"/><meta property="twitter:title" content="Example 4: Pareto surface · PortfolioOptimisers.jl"/><meta name="description" content="Documentation for PortfolioOptimisers.jl."/><meta property="og:description" content="Documentation for PortfolioOptimisers.jl."/><meta property="twitter:description" content="Documentation for PortfolioOptimisers.jl."/><meta property="og:url" content="https://dcelisgarza.github.io/PortfolioOptimisers.jl/examples/4-Pareto-Surface/"/><meta property="twitter:url" content="https://dcelisgarza.github.io/PortfolioOptimisers.jl/examples/4-Pareto-Surface/"/><link rel="canonical" href="https://dcelisgarza.github.io/PortfolioOptimisers.jl/examples/4-Pareto-Surface/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="PortfolioOptimisers.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PortfolioOptimisers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">PortfolioOptimisers</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../1-Getting-Started/">Example 1: Simple <code>MeanRisk</code> optimisation</a></li><li><a class="tocitem" href="../2-Mean-Risk-Objectives/">Example 2: <code>MeanRisk</code> objectives</a></li><li><a class="tocitem" href="../3-Efficient-Frontier/">Example 3: Efficient frontier</a></li><li class="is-active"><a class="tocitem" href>Example 4: Pareto surface</a><ul class="internal"><li><a class="tocitem" href="#1.-ReturnsResult-data"><span>1. ReturnsResult data</span></a></li><li><a class="tocitem" href="#2.-Preparing-solvers-for-pareto-surface"><span>2. Preparing solvers for pareto surface</span></a></li><li><a class="tocitem" href="#3.-High-order-prior-statistics"><span>3. High order prior statistics</span></a></li><li><a class="tocitem" href="#4.-Near-optimal-centering-pareto-surface"><span>4. Near optimal centering pareto surface</span></a></li><li><a class="tocitem" href="#5.-Visualising-the-pareto-surface"><span>5. Visualising the pareto surface</span></a></li></ul></li><li><a class="tocitem" href="../5-Budget-Constraints/">Example 5: Budget constraints</a></li></ul></li><li><a class="tocitem" href="../../090-contributing/">Contributing guidelines</a></li><li><a class="tocitem" href="../../091-developer/">Developer documentation</a></li><li><a class="tocitem" href="../../092-reference/">Reference</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../001-Base/">Base</a></li><li><a class="tocitem" href="../../002-Tools/">Tools</a></li><li><a class="tocitem" href="../../003-PosdefMatrix/">PosdefMatrix</a></li><li><a class="tocitem" href="../../004-Denoise/">Denoise</a></li><li><a class="tocitem" href="../../005-Detone/">Detone</a></li><li><a class="tocitem" href="../../006-MatrixProcessing/">Matrix Processing</a></li><li><input class="collapse-toggle" id="menuitem-6-7" type="checkbox"/><label class="tocitem" for="menuitem-6-7"><span class="docs-label">Moments</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../007-01-Moments/">Base Moments</a></li><li><a class="tocitem" href="../../007-02-Moments/">Mean</a></li><li><a class="tocitem" href="../../007-03-Moments/">Covariance</a></li><li><a class="tocitem" href="../../007-04-Moments/">Variance and Standard Deviation</a></li><li><a class="tocitem" href="../../007-05-Moments/">Gerber Covariance</a></li><li><a class="tocitem" href="../../007-06-Moments/">Smyth-Broby Covariance</a></li><li><a class="tocitem" href="../../007-07-Moments/">Distance Covariance</a></li><li><a class="tocitem" href="../../007-08-Moments/">Lower Tail Dependence Covariance</a></li><li><a class="tocitem" href="../../007-09-Moments/">Rank Covariances</a></li><li><a class="tocitem" href="../../007-10-Moments/">Histogram</a></li><li><a class="tocitem" href="../../007-11-Moments/">Mutual Information Covariance</a></li><li><a class="tocitem" href="../../007-12-Moments/">PortfolioOptimisersCovariance</a></li><li><a class="tocitem" href="../../007-13-Moments/">Shrunk Expected Returns</a></li><li><a class="tocitem" href="../../007-14-Moments/">Equilibrium expected returns</a></li><li><a class="tocitem" href="../../007-15-Moments/">Excess expected returns</a></li><li><a class="tocitem" href="../../007-16-Moments/">Coskewness</a></li><li><a class="tocitem" href="../../007-17-Moments/">Cokurtosis</a></li><li><a class="tocitem" href="../../007-18-Moments/">Regression</a></li><li><a class="tocitem" href="../../007-19-Moments/">Stepwise Regression</a></li><li><a class="tocitem" href="../../007-20-Moments/">Dimensional Reduction Regression</a></li><li><a class="tocitem" href="../../007-21-Moments/">Implied Volatility</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-8" type="checkbox"/><label class="tocitem" for="menuitem-6-8"><span class="docs-label">Distance</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../008-1-Distance/">Base Distance</a></li><li><a class="tocitem" href="../../008-2-Distance/">Distance</a></li><li><a class="tocitem" href="../../008-3-Distance/">Distances of Distances</a></li><li><a class="tocitem" href="../../008-4-Distance/">General Distance</a></li><li><a class="tocitem" href="../../008-5-Distance/">General Distance of Distances</a></li></ul></li><li><a class="tocitem" href="../../009-JuMPModelOptimisation/">JuMP Model Optimisation</a></li><li><a class="tocitem" href="../../010-OWA/">Ordered Weights Array</a></li><li><input class="collapse-toggle" id="menuitem-6-11" type="checkbox"/><label class="tocitem" for="menuitem-6-11"><span class="docs-label">Phylogeny</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../011-1-Phylogeny/">Base Phylogeny</a></li><li><a class="tocitem" href="../../011-2-Phylogeny/">Clustering</a></li><li><a class="tocitem" href="../../011-3-Phylogeny/">Hierarchical</a></li><li><a class="tocitem" href="../../011-4-Phylogeny/">Direct Bubble Hierarchy Tree</a></li><li><a class="tocitem" href="../../011-5-Phylogeny/">Phylogeny</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-12" type="checkbox"/><label class="tocitem" for="menuitem-6-12"><span class="docs-label">Constraint Generation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../012-1-ConstraintGeneration/">Base Constraint Generation</a></li><li><a class="tocitem" href="../../012-2-ConstraintGeneration/">Linear Constraints</a></li><li><a class="tocitem" href="../../012-3-ConstraintGeneration/">Phylogeny Constraints</a></li><li><a class="tocitem" href="../../012-4-ConstraintGeneration/">Weight Bounds</a></li><li><a class="tocitem" href="../../012-5-ConstraintGeneration/">Buy-in Threshold Constraints</a></li></ul></li><li><a class="tocitem" href="../../013-10-Prior/">Prior</a></li><li><a class="tocitem" href="../../019-15-Optimisation/">Optimisation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Example 4: Pareto surface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Example 4: Pareto surface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/main/examples/4-Pareto-Surface.jl#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p>The source files for all examples can be found in <a href="https://github.com/dcelisgarza/PortfolioOptimiser.jl/tree/main/examples/">/examples</a>.</p><h1 id="Example-4:-Pareto-surface"><a class="docs-heading-anchor" href="#Example-4:-Pareto-surface">Example 4: Pareto surface</a><a id="Example-4:-Pareto-surface-1"></a><a class="docs-heading-anchor-permalink" href="#Example-4:-Pareto-surface" title="Permalink"></a></h1><p>This example kicks up the complexity a couple of notches. We will introduce a new optimisation estimator, <code>NearOptimalCentering</code> optimiser.</p><pre><code class="language-julia hljs">using PortfolioOptimisers, PrettyTables
# Format for pretty tables.
tsfmt = (v, i, j) -&gt; begin
    if j == 1
        return Date(v)
    else
        return v
    end
end;
resfmt = (v, i, j) -&gt; begin
    if j == 1
        return v
    else
        return isa(v, Number) ? &quot;$(round(v*100, digits=3)) %&quot; : v
    end
end;</code></pre><h2 id="1.-ReturnsResult-data"><a class="docs-heading-anchor" href="#1.-ReturnsResult-data">1. ReturnsResult data</a><a id="1.-ReturnsResult-data-1"></a><a class="docs-heading-anchor-permalink" href="#1.-ReturnsResult-data" title="Permalink"></a></h2><p>We will use the same data as the previous example.</p><pre><code class="language-julia hljs">using CSV, TimeSeries, DataFrames

X = TimeArray(CSV.File(joinpath(@__DIR__, &quot;SP500.csv.gz&quot;)); timestamp = :Date)[(end - 252):end]
pretty_table(X[(end - 5):end]; formatters = tsfmt)

# Compute the returns
rd = prices_to_returns(X)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ReturnsResult
    nx | 20-element Vector{String}
     X | 252×20 Matrix{Float64}
    nf | nothing
     F | nothing
    ts | 252-element Vector{Dates.Date}
    iv | nothing
  ivpa | nothing
</code></pre><h2 id="2.-Preparing-solvers-for-pareto-surface"><a class="docs-heading-anchor" href="#2.-Preparing-solvers-for-pareto-surface">2. Preparing solvers for pareto surface</a><a id="2.-Preparing-solvers-for-pareto-surface-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Preparing-solvers-for-pareto-surface" title="Permalink"></a></h2><p>The pareto surface is a generalisation of the efficient frontier, in fact, we can even think of hypersurfaces if we provide more parameters, but that would be difficult to visualise, so we will stick to a 2D surface in 3D space.</p><p>We&#39;ll provide a vector of solvers beacause the optimisation type we&#39;ll be using is more complex, and will contain various constraints.</p><pre><code class="language-julia hljs">using Clarabel
slv = [Solver(; name = :clarabel1, solver = Clarabel.Optimizer,
              settings = Dict(&quot;verbose&quot; =&gt; false),
              check_sol = (; allow_local = true, allow_almost = true)),
       Solver(; name = :clarabel2, solver = Clarabel.Optimizer,
              settings = Dict(&quot;verbose&quot; =&gt; false, &quot;max_step_fraction&quot; =&gt; 0.95),
              check_sol = (; allow_local = true, allow_almost = true)),
       Solver(; name = :clarabel3, solver = Clarabel.Optimizer,
              settings = Dict(&quot;verbose&quot; =&gt; false, &quot;max_step_fraction&quot; =&gt; 0.9),
              check_sol = (; allow_local = true, allow_almost = true)),
       Solver(; name = :clarabel4, solver = Clarabel.Optimizer,
              settings = Dict(&quot;verbose&quot; =&gt; false, &quot;max_step_fraction&quot; =&gt; 0.85),
              check_sol = (; allow_local = true, allow_almost = true)),
       Solver(; name = :clarabel5, solver = Clarabel.Optimizer,
              settings = Dict(&quot;verbose&quot; =&gt; false, &quot;max_step_fraction&quot; =&gt; 0.8),
              check_sol = (; allow_local = true, allow_almost = true)),
       Solver(; name = :clarabel6, solver = Clarabel.Optimizer,
              settings = Dict(&quot;verbose&quot; =&gt; false, &quot;max_step_fraction&quot; =&gt; 0.75),
              check_sol = (; allow_local = true, allow_almost = true)),
       Solver(; name = :clarabel7, solver = Clarabel.Optimizer,
              settings = Dict(&quot;verbose&quot; =&gt; false, &quot;max_step_fraction&quot; =&gt; 0.70),
              check_sol = (; allow_local = true, allow_almost = true))];</code></pre><h2 id="3.-High-order-prior-statistics"><a class="docs-heading-anchor" href="#3.-High-order-prior-statistics">3. High order prior statistics</a><a id="3.-High-order-prior-statistics-1"></a><a class="docs-heading-anchor-permalink" href="#3.-High-order-prior-statistics" title="Permalink"></a></h2><p>We will once again precompute the prior statistics because otherwise they&#39;d have to be recomputed a few times.</p><p>We will be using high order risk measures, so we need to compute high order moments, we can do this with a <code>HighOrderPriorEstimator</code>, which needs a prior estimator that computes low order moments. Since we are only using a year of data, we will denoise our positive definite matrices by eliminating the eigenvalues corresponding to random noise. Denoising the non-positive definite matrix for the data we&#39;re using creates a negative square root, so we will not denoise it.</p><p>Note how many options this estimator contains.</p><pre><code class="language-julia hljs">de = Denoise(; alg = SpectralDenoise(;))
mp = DefaultMatrixProcessing(; denoise = de)
pe = HighOrderPriorEstimator(;
                             # Prior estimator for low order moments
                             pe = EmpiricalPrior(;
                                                 ce = PortfolioOptimisersCovariance(;
                                                                                    mp = mp)),
                             # Estimator for cokurtosis
                             kte = Cokurtosis(; mp = mp),
                             # Estimator for coskewness
                             ske = Coskewness())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HighOrderPriorEstimator
   pe | EmpiricalPrior
      |        ce | PortfolioOptimisersCovariance
      |           |   ce | Covariance
      |           |      |    me | SimpleExpectedReturns
      |           |      |       |   w | nothing
      |           |      |    ce | GeneralWeightedCovariance
      |           |      |       |   ce | SimpleCovariance: SimpleCovariance(true)
      |           |      |       |    w | nothing
      |           |      |   alg | Full()
      |           |   mp | DefaultMatrixProcessing
      |           |      |       pdm | Posdef
      |           |      |           |   alg | UnionAll: NearestCorrelationMatrix.Newton
      |           |      |   denoise | Denoise
      |           |      |           |      alg | SpectralDenoise()
      |           |      |           |     args | Tuple{}: ()
      |           |      |           |   kwargs | @NamedTuple{}: NamedTuple()
      |           |      |           |   kernel | typeof(AverageShiftedHistograms.Kernels.gaussian): AverageShiftedHistograms.Kernels.gaussian
      |           |      |           |        m | Int64: 10
      |           |      |           |        n | Int64: 1000
      |           |      |    detone | nothing
      |           |      |       alg | nothing
      |        me | SimpleExpectedReturns
      |           |   w | nothing
      |   horizon | nothing
  kte | Cokurtosis
      |    me | SimpleExpectedReturns
      |       |   w | nothing
      |    mp | DefaultMatrixProcessing
      |       |       pdm | Posdef
      |       |           |   alg | UnionAll: NearestCorrelationMatrix.Newton
      |       |   denoise | Denoise
      |       |           |      alg | SpectralDenoise()
      |       |           |     args | Tuple{}: ()
      |       |           |   kwargs | @NamedTuple{}: NamedTuple()
      |       |           |   kernel | typeof(AverageShiftedHistograms.Kernels.gaussian): AverageShiftedHistograms.Kernels.gaussian
      |       |           |        m | Int64: 10
      |       |           |        n | Int64: 1000
      |       |    detone | nothing
      |       |       alg | nothing
      |   alg | Full()
  ske | Coskewness
      |    me | SimpleExpectedReturns
      |       |   w | nothing
      |    mp | NonPositiveDefiniteMatrixProcessing
      |       |   denoise | nothing
      |       |    detone | nothing
      |       |       alg | nothing
      |   alg | Full()
</code></pre><p>Lets compute the prior statistics.</p><pre><code class="language-julia hljs">pr = prior(pe, rd)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HighOrderPrior
    pr | LowOrderPrior
       |         X | 252×20 Matrix{Float64}
       |        mu | 20-element Vector{Float64}
       |     sigma | 20×20 Matrix{Float64}
       |      chol | nothing
       |         w | nothing
       |       ens | nothing
       |       kld | nothing
       |        ow | nothing
       |        rr | nothing
       |      f_mu | nothing
       |   f_sigma | nothing
       |       f_w | nothing
    kt | 400×400 Matrix{Float64}
    L2 | 210×400 SparseArrays.SparseMatrixCSC{Int64, Int64}
    S2 | 210×400 SparseArrays.SparseMatrixCSC{Int64, Int64}
    sk | 20×400 Matrix{Float64}
     V | 20×20 Matrix{Float64}
  skmp | NonPositiveDefiniteMatrixProcessing
       |   denoise | nothing
       |    detone | nothing
       |       alg | nothing
</code></pre><p>In order to generate a pareto surface/hyper-surface, we need more dimensions than we&#39;ve previously explored. We can do this by adding more risk measure sweeps (and taking their product) to generate a mesh. <code>PortfolioOptimisers</code> does this internally and generally, but we will limit ourselves to two risk measures. This will generate a 2D surface which we can visualise in 3D.</p><p>We will use the square root <code>NegativeSkewness</code> and <code>SquareRootKurtosis</code>.</p><pre><code class="language-julia hljs">r1 = NegativeSkewness()
r2 = SquareRootKurtosis()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SquareRootKurtosis
  settings | RiskMeasureSettings
           |   scale | Float64: 1.0
           |      ub | nothing
           |     rke | Bool: true
         w | nothing
        mu | nothing
        kt | nothing
         N | nothing
       alg | Full()
</code></pre><h2 id="4.-Near-optimal-centering-pareto-surface"><a class="docs-heading-anchor" href="#4.-Near-optimal-centering-pareto-surface">4. Near optimal centering pareto surface</a><a id="4.-Near-optimal-centering-pareto-surface-1"></a><a class="docs-heading-anchor-permalink" href="#4.-Near-optimal-centering-pareto-surface" title="Permalink"></a></h2><p>First we need to get the bounds of our pareto surface. We can do this in many different ways, the simplest are:</p><ul><li>Minimise the risk using both risk measures simultaneously subject to optional constraints.</li><li>Maximise the return, utility or ratio subject to optional constraints.</li></ul><p>We will simply maximise the risk-return ratio for both risk measures on their own with no added constraints. This will not give a complete surface, but it will give us a reasonable range of values.</p><p>The <code>NearOptimalCentering</code> estimator will not return the portfolio which satisfies the traditional <code>MeanRisk</code> constraints, but rather a portfolio which is at the centre of an analytical region (neighbourhood) around the optimal solution. The region is parametrised by binning the efficient frontier, we will use the automatic bins here, but it is possible to define them manually.</p><pre><code class="language-julia hljs"># Risk-free rate of 4.2/100/252
rf = 4.2 / 100 / 252
opt = JuMPOptimiser(; pe = pr, slv = slv)
obj = MaximumRatio(; rf = rf)
opt1 = NearOptimalCentering(; r = r1, obj = obj, opt = opt)
opt2 = NearOptimalCentering(; r = r2, obj = obj, opt = opt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NearOptimalCentering
        opt | JuMPOptimiser
            |       pe | HighOrderPrior
            |          |     pr | LowOrderPrior
            |          |        |         X | 252×20 Matrix{Float64}
            |          |        |        mu | 20-element Vector{Float64}
            |          |        |     sigma | 20×20 Matrix{Float64}
            |          |        |      chol | nothing
            |          |        |         w | nothing
            |          |        |       ens | nothing
            |          |        |       kld | nothing
            |          |        |        ow | nothing
            |          |        |        rr | nothing
            |          |        |      f_mu | nothing
            |          |        |   f_sigma | nothing
            |          |        |       f_w | nothing
            |          |     kt | 400×400 Matrix{Float64}
            |          |     L2 | 210×400 SparseArrays.SparseMatrixCSC{Int64, Int64}
            |          |     S2 | 210×400 SparseArrays.SparseMatrixCSC{Int64, Int64}
            |          |     sk | 20×400 Matrix{Float64}
            |          |      V | 20×20 Matrix{Float64}
            |          |   skmp | NonPositiveDefiniteMatrixProcessing
            |          |        |   denoise | nothing
            |          |        |    detone | nothing
            |          |        |       alg | nothing
            |      slv | 7-element Vector{Solver{Symbol, UnionAll, T3, @NamedTuple{allow_local::Bool, allow_almost::Bool}, Bool} where T3}
            |       wb | WeightBounds
            |          |   lb | Float64: 0.0
            |          |   ub | Float64: 1.0
            |      bgt | Float64: 1.0
            |     sbgt | nothing
            |       lt | nothing
            |       st | nothing
            |      lcs | nothing
            |      lcm | nothing
            |     cent | nothing
            |    gcard | nothing
            |   sgcard | nothing
            |     smtx | nothing
            |    sgmtx | nothing
            |      slt | nothing
            |      sst | nothing
            |     sglt | nothing
            |     sgst | nothing
            |     sets | nothing
            |     nplg | nothing
            |     cplg | nothing
            |       tn | nothing
            |       te | nothing
            |     fees | nothing
            |      ret | ArithmeticReturn
            |          |   ucs | nothing
            |          |    lb | nothing
            |      sce | SumScalariser: SumScalariser()
            |     ccnt | nothing
            |     cobj | nothing
            |       sc | Int64: 1
            |       so | Int64: 1
            |     card | nothing
            |    scard | nothing
            |      nea | nothing
            |       l1 | nothing
            |       l2 | nothing
            |       ss | nothing
            |   strict | Bool: false
          r | SquareRootKurtosis
            |   settings | RiskMeasureSettings
            |            |   scale | Float64: 1.0
            |            |      ub | nothing
            |            |     rke | Bool: true
            |          w | nothing
            |         mu | nothing
            |         kt | nothing
            |          N | nothing
            |        alg | Full()
        obj | MaximumRatio
            |    rf | Float64: 0.0001666666666666667
            |   ohf | nothing
       bins | nothing
      w_min | nothing
  w_min_ini | nothing
      w_opt | nothing
  w_opt_ini | nothing
      w_max | nothing
  w_max_ini | nothing
   ucs_flag | Bool: true
        alg | UnconstrainedNearOptimalCentering()
   fallback | nothing
</code></pre><p>Note the number of options in the estimator. In particular the <code>alg</code> property. Which in this case means the <code>NearOptimalCentering</code> alg will not have any external constraints applied to it.</p><p>Lets optimise the portfolios.</p><pre><code class="language-julia hljs">res1 = optimise!(opt1)
res2 = optimise!(opt2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NearOptimalCenteringOptimisation
             oe | DataType: NearOptimalCentering
             pa | ProcessedJuMPOptimiserAttributes
                |       pr | HighOrderPrior
                |          |     pr | LowOrderPrior
                |          |        |         X | 252×20 Matrix{Float64}
                |          |        |        mu | 20-element Vector{Float64}
                |          |        |     sigma | 20×20 Matrix{Float64}
                |          |        |      chol | nothing
                |          |        |         w | nothing
                |          |        |       ens | nothing
                |          |        |       kld | nothing
                |          |        |        ow | nothing
                |          |        |        rr | nothing
                |          |        |      f_mu | nothing
                |          |        |   f_sigma | nothing
                |          |        |       f_w | nothing
                |          |     kt | 400×400 Matrix{Float64}
                |          |     L2 | 210×400 SparseArrays.SparseMatrixCSC{Int64, Int64}
                |          |     S2 | 210×400 SparseArrays.SparseMatrixCSC{Int64, Int64}
                |          |     sk | 20×400 Matrix{Float64}
                |          |      V | 20×20 Matrix{Float64}
                |          |   skmp | NonPositiveDefiniteMatrixProcessing
                |          |        |   denoise | nothing
                |          |        |    detone | nothing
                |          |        |       alg | nothing
                |       wb | WeightBounds
                |          |   lb | 20-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}
                |          |   ub | 20-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}
                |       lt | nothing
                |       st | nothing
                |      lcs | nothing
                |     cent | nothing
                |    gcard | nothing
                |   sgcard | nothing
                |     smtx | nothing
                |    sgmtx | nothing
                |      slt | nothing
                |      sst | nothing
                |     sglt | nothing
                |     sgst | nothing
                |     nplg | nothing
                |     cplg | nothing
                |       tn | nothing
                |     fees | nothing
                |      ret | ArithmeticReturn
                |          |   ucs | nothing
                |          |    lb | nothing
  w_min_retcode | OptimisationSuccess
                |   res | Dict{Any, Any}: Dict{Any, Any}()
  w_opt_retcode | OptimisationSuccess
                |   res | Dict{Any, Any}: Dict{Any, Any}()
  w_max_retcode | OptimisationSuccess
                |   res | Dict{Any, Any}: Dict{Any, Any}()
    noc_retcode | OptimisationSuccess
                |   res | Dict{Any, Any}: Dict{Any, Any}(:clarabel1 =&gt; Dict{Symbol, Any}(:settings =&gt; Dict{String, Bool}(&quot;verbose&quot; =&gt; 0), :err =&gt; solution_summary(; result = 1, verbose = false)
                | ├ solver_name          : Clarabel
                | ├ Termination
                | │ ├ termination_status : SLOW_PROGRESS
                | │ ├ result_count       : 1
                | │ └ raw_status         : INSUFFICIENT_PROGRESS
                | ├ Solution (result = 1)
                | │ ├ primal_status        : OTHER_RESULT_STATUS
                | │ ├ dual_status          : OTHER_RESULT_STATUS
                | │ ├ objective_value      : 9.29400e+01
                | │ └ dual_objective_value : 9.29050e+01
                | └ Work counters
                |   ├ solve_time (sec)   : 2.60887e-01
                |   └ barrier_iterations : 35))
        retcode | OptimisationSuccess
                |   res | nothing
            sol | PortfolioOptimisers.JuMPOptimisationSolution
                |   w | 20-element Vector{Float64}
          model | A JuMP Model
                | ├ solver: Clarabel
                | ├ objective_sense: MIN_SENSE
                | │ └ objective_function_type: JuMP.AffExpr
                | ├ num_variables: 273
                | ├ num_constraints: 47
                | │ ├ JuMP.AffExpr in MOI.EqualTo{Float64}: 1
                | │ ├ Vector{JuMP.AffExpr} in MOI.Nonnegatives: 1
                | │ ├ Vector{JuMP.AffExpr} in MOI.Nonpositives: 1
                | │ ├ Vector{JuMP.AffExpr} in MOI.SecondOrderCone: 1
                | │ ├ Vector{JuMP.AffExpr} in MOI.ExponentialCone: 42
                | │ └ Vector{JuMP.AffExpr} in MOI.PositiveSemidefiniteConeSquare: 1
                | └ Names registered in the model
                |   └ :M_PSD, :W, :W_M, :bgt, :ckurt_soc_1, :clog_delta_w, :clog_ret, :clog_risk, :clog_w, :k, :log_delta_w, :log_ret, :log_risk, :log_w, :lw, :obj_expr, :ret, :risk, :risk_vec, :sc, :so, :sqrt_kurtosis_risk_1, :w, :w_lb, :w_ub, :zkurt_1
</code></pre><p>In order to allow for multiple risk measures in optimisations, certain measures can take different parameters. In this case, <code>NegativeSkewness</code> and <code>SquareRootKurtosis</code> take the moment matrices, which are used to compute the risk measures. We can use the <code>factory</code> function to create a new risk measure with the same parameters as the original, but with the moment matrices from the prior. Other risk measures require a solver, and this function is also used in those cases.</p><pre><code class="language-julia hljs">r1 = factory(r1, pr)
r2 = factory(r2, pr)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SquareRootKurtosis
  settings | RiskMeasureSettings
           |   scale | Float64: 1.0
           |      ub | nothing
           |     rke | Bool: true
         w | nothing
        mu | 20-element Vector{Float64}
        kt | 400×400 Matrix{Float64}
         N | nothing
       alg | Full()
</code></pre><p>Lets compute the risk bounds for the pareto surface. We need to compute four risks because we have two risk measures and two optimisations. This will let us pick the lower and upper bounds for each risk measure, as we explore the pareto surface from one optimisation to the other.</p><pre><code class="language-julia hljs">sk_rk1 = expected_risk(r1, res1.w, pr.X);
kt_rk1 = expected_risk(r2, res1.w, pr.X);
sk_rk2 = expected_risk(r1, res2.w, pr.X);
kt_rk2 = expected_risk(r2, res2.w, pr.X);</code></pre><p>We will now create new risk measures bounded by these values. We will also use factories from the get-go. The optimisation procedure prioritises the parameters in the risk measures over the ones in the prior. This lets users provide the same risk measure with different parameters in the same optimisation. We will use two ranges of 5. The total number of points in the pareto surface will be the product of the points of each range.</p><p>Since we don&#39;t know which <code>sk_rk1</code> or <code>sk_r2</code>, <code>kt_rk1</code> or <code>kt_rk2</code> is bigger or smaller, we need to use <code>min</code>, <code>max</code>.</p><pre><code class="language-julia hljs">r1 = factory(NegativeSkewness(;
                              settings = RiskMeasureSettings(;
                                                             # Risk upper bounds go from the minimum to maximum risk given the optimisations.
                                                             ub = range(;
                                                                        start = min(sk_rk1,
                                                                                    sk_rk2),
                                                                        stop = max(sk_rk1,
                                                                                   sk_rk2),
                                                                        length = 5))), pr);
r2 = factory(SquareRootKurtosis(;
                                settings = RiskMeasureSettings(;
                                                               ub = range(;
                                                                          start = min(kt_rk1,
                                                                                      kt_rk2),
                                                                          stop = max(kt_rk1,
                                                                                     kt_rk2),
                                                                          length = 5))), pr);</code></pre><p>Now we only need to maximise the return given both risk measures. Internally, the optimisation will generate the mesh as a product of the ranges in the order in which the risk measures were provided. This also works with the <code>MeanRisk</code> estimatro, in fact, <code>NearOptimalCentering</code> uses it internally.</p><p>Since we are using an unconstrained <code>NearOptimalCentering</code>, the risk bound constraints will not be satisfied by the solution. If we wish to satisfy them, we can provide <code>alg = ConstrainedNearOptimalCentering()</code>, but would also make the optimisations harder, which may cause them to fail.</p><pre><code class="language-julia hljs">opt3 = NearOptimalCentering(; r = [r1, r2], obj = MaximumReturn(), opt = opt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NearOptimalCentering
        opt | JuMPOptimiser
            |       pe | HighOrderPrior
            |          |     pr | LowOrderPrior
            |          |        |         X | 252×20 Matrix{Float64}
            |          |        |        mu | 20-element Vector{Float64}
            |          |        |     sigma | 20×20 Matrix{Float64}
            |          |        |      chol | nothing
            |          |        |         w | nothing
            |          |        |       ens | nothing
            |          |        |       kld | nothing
            |          |        |        ow | nothing
            |          |        |        rr | nothing
            |          |        |      f_mu | nothing
            |          |        |   f_sigma | nothing
            |          |        |       f_w | nothing
            |          |     kt | 400×400 Matrix{Float64}
            |          |     L2 | 210×400 SparseArrays.SparseMatrixCSC{Int64, Int64}
            |          |     S2 | 210×400 SparseArrays.SparseMatrixCSC{Int64, Int64}
            |          |     sk | 20×400 Matrix{Float64}
            |          |      V | 20×20 Matrix{Float64}
            |          |   skmp | NonPositiveDefiniteMatrixProcessing
            |          |        |   denoise | nothing
            |          |        |    detone | nothing
            |          |        |       alg | nothing
            |      slv | 7-element Vector{Solver{Symbol, UnionAll, T3, @NamedTuple{allow_local::Bool, allow_almost::Bool}, Bool} where T3}
            |       wb | WeightBounds
            |          |   lb | Float64: 0.0
            |          |   ub | Float64: 1.0
            |      bgt | Float64: 1.0
            |     sbgt | nothing
            |       lt | nothing
            |       st | nothing
            |      lcs | nothing
            |      lcm | nothing
            |     cent | nothing
            |    gcard | nothing
            |   sgcard | nothing
            |     smtx | nothing
            |    sgmtx | nothing
            |      slt | nothing
            |      sst | nothing
            |     sglt | nothing
            |     sgst | nothing
            |     sets | nothing
            |     nplg | nothing
            |     cplg | nothing
            |       tn | nothing
            |       te | nothing
            |     fees | nothing
            |      ret | ArithmeticReturn
            |          |   ucs | nothing
            |          |    lb | nothing
            |      sce | SumScalariser: SumScalariser()
            |     ccnt | nothing
            |     cobj | nothing
            |       sc | Int64: 1
            |       so | Int64: 1
            |     card | nothing
            |    scard | nothing
            |      nea | nothing
            |       l1 | nothing
            |       l2 | nothing
            |       ss | nothing
            |   strict | Bool: false
          r | Vector{PortfolioOptimisers.RiskMeasure}: PortfolioOptimisers.RiskMeasure[NegativeSkewness
  settings | RiskMeasureSettings
           |   scale | Float64: 1.0
           |      ub | StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}: 0.0014407874342906597:0.00010182732908744173:0.0018480967506404266
           |     rke | Bool: true
        mp | NonPositiveDefiniteMatrixProcessing
           |   denoise | nothing
           |    detone | nothing
           |       alg | nothing
        sk | 20×400 Matrix{Float64}
         V | 20×20 Matrix{Float64}
       alg | SqrtRiskExpr()
, SquareRootKurtosis
  settings | RiskMeasureSettings
           |   scale | Float64: 1.0
           |      ub | StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}: 0.00023763521983569873:7.758896959421372e-6:0.0002686708076733842
           |     rke | Bool: true
         w | nothing
        mu | 20-element Vector{Float64}
        kt | 400×400 Matrix{Float64}
         N | nothing
       alg | Full()
]
        obj | MaximumReturn()
       bins | nothing
      w_min | nothing
  w_min_ini | nothing
      w_opt | nothing
  w_opt_ini | nothing
      w_max | nothing
  w_max_ini | nothing
   ucs_flag | Bool: true
        alg | UnconstrainedNearOptimalCentering()
   fallback | nothing
</code></pre><p>See how <code>r</code> is a vector of risk measures with populated properties. We can now optimise the porftolios.</p><pre><code class="language-julia hljs">res3 = optimise!(opt3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">NearOptimalCenteringOptimisation
             oe | DataType: NearOptimalCentering
             pa | ProcessedJuMPOptimiserAttributes
                |       pr | HighOrderPrior
                |          |     pr | LowOrderPrior
                |          |        |         X | 252×20 Matrix{Float64}
                |          |        |        mu | 20-element Vector{Float64}
                |          |        |     sigma | 20×20 Matrix{Float64}
                |          |        |      chol | nothing
                |          |        |         w | nothing
                |          |        |       ens | nothing
                |          |        |       kld | nothing
                |          |        |        ow | nothing
                |          |        |        rr | nothing
                |          |        |      f_mu | nothing
                |          |        |   f_sigma | nothing
                |          |        |       f_w | nothing
                |          |     kt | 400×400 Matrix{Float64}
                |          |     L2 | 210×400 SparseArrays.SparseMatrixCSC{Int64, Int64}
                |          |     S2 | 210×400 SparseArrays.SparseMatrixCSC{Int64, Int64}
                |          |     sk | 20×400 Matrix{Float64}
                |          |      V | 20×20 Matrix{Float64}
                |          |   skmp | NonPositiveDefiniteMatrixProcessing
                |          |        |   denoise | nothing
                |          |        |    detone | nothing
                |          |        |       alg | nothing
                |       wb | WeightBounds
                |          |   lb | 20-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}
                |          |   ub | 20-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}
                |       lt | nothing
                |       st | nothing
                |      lcs | nothing
                |     cent | nothing
                |    gcard | nothing
                |   sgcard | nothing
                |     smtx | nothing
                |    sgmtx | nothing
                |      slt | nothing
                |      sst | nothing
                |     sglt | nothing
                |     sgst | nothing
                |     nplg | nothing
                |     cplg | nothing
                |       tn | nothing
                |     fees | nothing
                |      ret | ArithmeticReturn
                |          |   ucs | nothing
                |          |    lb | nothing
  w_min_retcode | OptimisationSuccess
                |   res | Dict{Any, Any}: Dict{Any, Any}()
  w_opt_retcode | 25-element Vector{PortfolioOptimisers.OptimisationReturnCode}
  w_max_retcode | OptimisationSuccess
                |   res | Dict{Any, Any}: Dict{Any, Any}()
    noc_retcode | 25-element Vector{PortfolioOptimisers.OptimisationReturnCode}
        retcode | OptimisationSuccess
                |   res | nothing
            sol | 25-element Vector{PortfolioOptimisers.JuMPOptimisationSolution}
          model | A JuMP Model
                | ├ solver: Clarabel
                | ├ objective_sense: MIN_SENSE
                | │ └ objective_function_type: JuMP.AffExpr
                | ├ num_variables: 274
                | ├ num_constraints: 48
                | │ ├ JuMP.AffExpr in MOI.EqualTo{Float64}: 1
                | │ ├ Vector{JuMP.AffExpr} in MOI.Nonnegatives: 1
                | │ ├ Vector{JuMP.AffExpr} in MOI.Nonpositives: 1
                | │ ├ Vector{JuMP.AffExpr} in MOI.SecondOrderCone: 2
                | │ ├ Vector{JuMP.AffExpr} in MOI.ExponentialCone: 42
                | │ └ Vector{JuMP.AffExpr} in MOI.PositiveSemidefiniteConeSquare: 1
                | └ Names registered in the model
                |   └ :M_PSD, :W, :W_M, :bgt, :ckurt_soc_2, :clog_delta_w, :clog_ret, :clog_risk, :clog_w, :cnskew_soc_1, :k, :log_delta_w, :log_ret, :log_risk, :log_w, :lw, :nskew_risk_1, :obj_expr, :ret, :risk, :risk_vec, :sc, :so, :sqrt_kurtosis_risk_2, :w, :w_lb, :w_ub, :zkurt_2
</code></pre><p>As expected, there are <code>5 × 5 = 25</code> solutions. Thankfully there are no warnings about failed optimisations, so there is no need to check the solutions.</p><p>The <code>NearOptimalCentering</code> estimator contains various return codes because it may need to compute some <code>MeanRisk</code> optimisations, it has a <code>retcode</code> which summarises whether all other optimisations succeeded. We can check this to make sure it was a success.</p><pre><code class="language-julia hljs">isa(res3.retcode, OptimisationSuccess)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h2 id="5.-Visualising-the-pareto-surface"><a class="docs-heading-anchor" href="#5.-Visualising-the-pareto-surface">5. Visualising the pareto surface</a><a id="5.-Visualising-the-pareto-surface-1"></a><a class="docs-heading-anchor-permalink" href="#5.-Visualising-the-pareto-surface" title="Permalink"></a></h2><p>Lets view how the weights evolve along the pareto surface.</p><pre><code class="language-julia hljs">using StatsPlots, GraphRecipes
plot_stacked_area_composition(res3.w, rd.nx)</code></pre><img src="2ec0bb4b.svg" alt="Example block output"/><p>Now we can view the parteo surface. For the z-axis and colourbar, we will use the conditional drawdown at risk to return ratio.</p><pre><code class="language-julia hljs">plot_measures(res3.w, pr; x = r1, y = r2,
              z = RatioRiskMeasure(; rk = ConditionalDrawdownatRisk(),
                                   rt = ArithmeticReturn(), rf = rf),
              c = RatioRiskMeasure(; rk = ConditionalDrawdownatRisk(),
                                   rt = ArithmeticReturn(), rf = rf),
              title = &quot;Pareto Surface&quot;, xlabel = &quot;Sqrt NSke&quot;, ylabel = &quot;Sqrt Kt&quot;,
              zlabel = &quot;CDaR/Return&quot;)</code></pre><img src="b961a15a.svg" alt="Example block output"/><p>We can view it in 2D as well.</p><pre><code class="language-julia hljs">gr()
plot_measures(res3.w, pr; x = r1, y = r2,
              c = RatioRiskMeasure(; rk = ConditionalDrawdownatRisk(),
                                   rt = ArithmeticReturn(), rf = rf),
              title = &quot;Pareto Front&quot;, xlabel = &quot;Sqrt NSke&quot;, ylabel = &quot;Sqrt Kt&quot;,
              colorbar_title = &quot;\n\nCDaR/Return&quot;, right_margin = 8Plots.mm)</code></pre><img src="22e04578.svg" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../3-Efficient-Frontier/">« Example 3: Efficient frontier</a><a class="docs-footer-nextpage" href="../5-Budget-Constraints/">Example 5: Budget constraints »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Saturday 20 September 2025 15:57">Saturday 20 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
