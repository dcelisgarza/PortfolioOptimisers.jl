import{_ as i,c as a,o as t,aA as s}from"./chunks/framework.DKYrEMbT.js";const u=JSON.parse('{"title":"Introduction to the API","description":"","frontmatter":{},"headers":[],"relativePath":"api/00_API_Introduction.md","filePath":"api/00_API_Introduction.md","lastUpdated":null}'),n={name:"api/00_API_Introduction.md"};function o(r,e,l,c,d,h){return t(),a("div",null,[...e[0]||(e[0]=[s('<h1 id="Introduction-to-the-API" tabindex="-1">Introduction to the API <a class="header-anchor" href="#Introduction-to-the-API" aria-label="Permalink to &quot;Introduction to the API {#Introduction-to-the-API}&quot;">​</a></h1><p>This section explains <code>PortfolioOptimisers.jl</code> API in detail. The pages are organised in exactly the same way as the <code>src</code> folder itself. This means there should be a 1 to 1 correspondence between documentation and source files<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>.</p><h2 id="Design-philosophy" tabindex="-1">Design philosophy <a class="header-anchor" href="#Design-philosophy" aria-label="Permalink to &quot;Design philosophy {#Design-philosophy}&quot;">​</a></h2><p>There are three overarching design choices in <code>PortfolioOptimisers.jl</code>:</p><h3 id="1.-Well-defined-type-hierarchies" tabindex="-1">1. Well-defined type hierarchies <a class="header-anchor" href="#1.-Well-defined-type-hierarchies" aria-label="Permalink to &quot;1. Well-defined type hierarchies {#1.-Well-defined-type-hierarchies}&quot;">​</a></h3><ul><li>Easily and quickly add new features by sticking to defined interfaces.</li></ul><h3 id="2.-Strongly-typed-immutable-structs" tabindex="-1">2. Strongly typed immutable structs <a class="header-anchor" href="#2.-Strongly-typed-immutable-structs" aria-label="Permalink to &quot;2. Strongly typed immutable structs {#2.-Strongly-typed-immutable-structs}&quot;">​</a></h3><ul><li><p>All types are concrete and known at instantiation.</p></li><li><p>Constants can be propagated if necessary.</p></li><li><p>There is always a single immutable source of truth for every process.</p></li><li><p>If needed, modifying values must be done via interface functions, which simplifies finding and fixing bugs. If the interface for modification is not provided the code will throw a missing method exception.</p></li><li><p>Future developments may make use of <a href="https://github.com/JuliaObjects/Accessors.jl" target="_blank" rel="noreferrer"><code>Accessors.jl</code></a> for certain things.</p></li></ul><h3 id="3.-Compositional-design" tabindex="-1">3. Compositional design <a class="header-anchor" href="#3.-Compositional-design" aria-label="Permalink to &quot;3. Compositional design {#3.-Compositional-design}&quot;">​</a></h3><ul><li><p><code>PortfolioOptimisers.jl</code> is a toolkit whose components can interact in complex, deeply nested ways.</p></li><li><p>Separation of concerns lets us subdivide logical components into isolated, self-contained units. Leading to easier and fearless development and testing.</p></li><li><p>Extensive and judicious data validation checks are performed at the earliest possible moment–-mostly at variable instantiation–-to ensure correctness.</p></li><li><p>Turtles all the way down. Structures can be used, reused, and nested in many ways. This allows for efficient data reuse and arbitrary complexity.</p></li></ul><h2 id="Design-goals" tabindex="-1">Design goals <a class="header-anchor" href="#Design-goals" aria-label="Permalink to &quot;Design goals {#Design-goals}&quot;">​</a></h2><p>This philosophy has three primary goals:</p><h3 id="1.-Maintainability-and-expandability" tabindex="-1">1. Maintainability and expandability <a class="header-anchor" href="#1.-Maintainability-and-expandability" aria-label="Permalink to &quot;1. Maintainability and expandability {#1.-Maintainability-and-expandability}&quot;">​</a></h3><ul><li><p>The only way to break existing functionality should be by modifying APIs.</p></li><li><p>Adding functionality should be a case of subtyping existing abstract types and implementing the correct interfaces.</p></li><li><p>Avoid leaking side effects to other components unless completely necessary. An example of this is entropy pooling requiring the use of a vector of observation weights which must be taken into account in different, largely unrelated places.</p></li></ul><h3 id="2.-Correctness-and-robustness" tabindex="-1">2. Correctness and robustness <a class="header-anchor" href="#2.-Correctness-and-robustness" aria-label="Permalink to &quot;2. Correctness and robustness {#2.-Correctness-and-robustness}&quot;">​</a></h3><ul><li>Each subunit should perform its own data validation as early as possible unless it absolutely needs downstream data.</li></ul><h3 id="3.-Performance" tabindex="-1">3. Performance <a class="header-anchor" href="#3.-Performance" aria-label="Permalink to &quot;3. Performance {#3.-Performance}&quot;">​</a></h3><ul><li><p>Types and constants are always fully known at inference time.</p></li><li><p>Immutability ensures smaller structs live in the stack.</p></li></ul><h2 id="Contents" tabindex="-1">Contents <a class="header-anchor" href="#Contents" aria-label="Permalink to &quot;Contents {#Contents}&quot;">​</a></h2><ul><li><a href="./01_Base#base">Base</a><ul><li><a href="./01_Base#Base-abstract-types">Base abstract types</a></li><li><a href="./01_Base#Pretty-printing">Pretty printing</a></li><li><a href="./01_Base#Error-types">Error types</a></li><li><a href="./01_Base#Utility-types">Utility types</a></li><li><a href="./01_Base#Base-type-aliases">Base type aliases</a></li></ul></li><li><a href="./02_Tools#tools">Tools</a><ul><li><a href="./02_Tools#Utility-functions">Utility functions</a></li><li><a href="./02_Tools#assertions">Assertions</a></li><li><a href="./02_Tools#Mathematical-functions">Mathematical functions</a></li><li><a href="./02_Tools#View-functions">View functions</a></li><li><a href="./02_Tools#Summary-statistics">Summary statistics</a></li></ul></li><li><a href="./03_Preprocessing#Pre-processing">Pre processing</a><ul><li><a href="./03_Preprocessing#Prices-to-returns">Prices to returns</a></li><li><a href="./03_Preprocessing#Pre-filtering">Pre filtering</a></li></ul></li><li><a href="./04_PosdefMatrix#Positive-definite-matrix-projection">Positive definite matrix projection</a></li><li><a href="./05_Denoise#denoise">Denoise</a></li><li><a href="./06_Detone#detone">Detone</a></li><li><a href="./07_MatrixProcessing#Matrix-processing">Matrix processing</a></li><li><a href="./08_Moments/01_Base_Moments#Base-moments">Base moments</a></li><li><a href="./08_Moments/02_SimpleExpectedReturns#Simple-expected-returns">Simple expected returns</a></li><li><a href="./08_Moments/03_Covariance#api-covariance">api covariance</a></li><li><a href="./08_Moments/04_SimpleVariance#Variance-and-standard-deviation">Variance and standard deviation</a></li><li><a href="./08_Moments/05_GerberCovariances#Gerber-covariance">Gerber covariance</a></li><li><a href="./08_Moments/06_SmythBrobyCovariance#Smyth-Broby-Covariance">Smyth Broby Covariance</a></li><li><a href="./08_Moments/07_DistanceCovariance#Distance-Covariance">Distance Covariance</a></li><li><a href="./08_Moments/08_LowerTailDependenceCovariance#Lower-Tail-Dependence-Covariance">Lower Tail Dependence Covariance</a></li><li><a href="./08_Moments/09_RankCovariance#Rank-Covariances">Rank Covariances</a></li><li><a href="./08_Moments/10_Histogram#histogram">Histogram</a></li><li><a href="./08_Moments/11_MutualInfoCovariance#Mutual-Information-Covariance">Mutual Information Covariance</a></li><li><a href="./09_Distance/01_Base_Distance#Base-Distance">Base Distance</a></li><li><a href="./09_Distance/02_Distance#api-distance">api distance</a></li><li><a href="./09_Distance/03_DistanceDistance#Distances-of-Distances">Distances of Distances</a></li><li><a href="./10_JuMPModelOptimisation#JuMP-model-optimisation">JuMP model optimisation</a></li><li><a href="./18_Tracking#tracking">Tracking</a><ul><li><a href="./18_Tracking#public">Public</a></li><li><a href="./18_Tracking#private">Private</a></li></ul></li><li><a href="./19_RiskMeasures/01_Base_RiskMeasures#Base-Risk-Measures">Base Risk Measures</a></li><li><a href="./19_RiskMeasures/02_Variance#variance">Variance</a></li><li><a href="./19_RiskMeasures/03_MomentRiskMeasures#Moment-Risk-Measures">Moment Risk Measures</a></li><li><a href="./19_RiskMeasures/04_Kurtosis#kurtosis">Kurtosis</a></li><li><a href="./19_RiskMeasures/05_NegativeSkewness#Negative-Skewness">Negative Skewness</a></li><li><a href="./19_RiskMeasures/06_XatRisk#X-at-Risk">X at Risk</a></li><li><a href="./19_RiskMeasures/07_ConditionalXatRisk#Conditional-X-at-Risk">Conditional X at Risk</a></li><li><a href="./19_RiskMeasures/08_EntropicXatRisk#Entropic-X-at-Risk">Entropic X at Risk</a></li><li><a href="./19_RiskMeasures/09_RelativisticXatRisk#Relativistic-X-at-Risk">Relativistic X at Risk</a></li><li><a href="./19_RiskMeasures/17_TurnoverRiskMeasure#Turnover-risk-measure">Turnover risk measure</a></li><li><a href="./19_RiskMeasures/24_ExpectedRisk#Expected-Risk">Expected Risk</a></li><li><a href="./20_Optimisation/01_Base_Optimisation#Base-optimisation">Base optimisation</a></li><li><a href="./20_Optimisation/02_NaiveOptimisation#Naive-optimisation">Naive optimisation</a></li><li><a href="./22_Plotting#plotting">Plotting</a></li><li><a href="./23_Interfaces#interfaces">Interfaces</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Except for a few cases, most of which are convenience function overloads. This means some links do not go to the exact method definition. Other than hard-coding links to specific lines of code, which is fragile, I haven&#39;t found an easy solution. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>',22)])])}const f=i(n,[["render",o]]);export{u as __pageData,f as default};
