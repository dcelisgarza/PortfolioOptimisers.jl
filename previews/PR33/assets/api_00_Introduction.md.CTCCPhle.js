import{_ as a,c as i,o as t,aA as n}from"./chunks/framework.DI9JD8Bb.js";const u=JSON.parse('{"title":"Introduction","description":"","frontmatter":{},"headers":[],"relativePath":"api/00_Introduction.md","filePath":"api/00_Introduction.md","lastUpdated":null}'),o={name:"api/00_Introduction.md"};function s(l,e,r,d,c,h){return t(),i("div",null,[...e[0]||(e[0]=[n('<h1 id="Introduction" tabindex="-1">Introduction <a class="header-anchor" href="#Introduction" aria-label="Permalink to &quot;Introduction {#Introduction}&quot;">​</a></h1><p>This section explains <code>PortfolioOptimisers.jl</code> API in detail. The pages are organised in exactly the same way as the <code>src</code> folder itself. This means there should be a 1 to 1 correspondence between documentation and source files<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>.</p><h2 id="Design-philosophy" tabindex="-1">Design philosophy <a class="header-anchor" href="#Design-philosophy" aria-label="Permalink to &quot;Design philosophy {#Design-philosophy}&quot;">​</a></h2><p>There are three overarching design choices in <code>PortfolioOptimisers.jl</code>:</p><h3 id="1.-Well-defined-type-hierarchies" tabindex="-1">1. Well-defined type hierarchies <a class="header-anchor" href="#1.-Well-defined-type-hierarchies" aria-label="Permalink to &quot;1. Well-defined type hierarchies {#1.-Well-defined-type-hierarchies}&quot;">​</a></h3><ul><li>Easily and quickly add new features by sticking to defined interfaces.</li></ul><h3 id="2.-Strongly-typed-immutable-structs" tabindex="-1">2. Strongly typed immutable structs <a class="header-anchor" href="#2.-Strongly-typed-immutable-structs" aria-label="Permalink to &quot;2. Strongly typed immutable structs {#2.-Strongly-typed-immutable-structs}&quot;">​</a></h3><ul><li><p>All types are concrete and known at instantiation.</p></li><li><p>Constants can be propagated if necessary.</p></li><li><p>There is always a single immutable source of truth for every process.</p></li><li><p>If needed, modifying values must be done via interface functions, which simplifies finding and fixing bugs. If the interface for modification is not provided the code will throw a missing method exception.</p></li><li><p>Future developments may make use of <a href="https://github.com/JuliaObjects/Accessors.jl" target="_blank" rel="noreferrer"><code>Accessors.jl</code></a> for certain things.</p></li></ul><h3 id="3.-Compositional-design" tabindex="-1">3. Compositional design <a class="header-anchor" href="#3.-Compositional-design" aria-label="Permalink to &quot;3. Compositional design {#3.-Compositional-design}&quot;">​</a></h3><ul><li><p><code>PortfolioOptimisers.jl</code> is a toolkit whose components can interact in complex, deeply nested ways.</p></li><li><p>Separation of concerns lets us subdivide logical components into isolated, self-contained units. Leading to easier and fearless development and testing.</p></li><li><p>Extensive and judicious data validation checks are performed at the earliest possible moment–-mostly at variable instantiation–-to ensure correctness.</p></li><li><p>Turtles all the way down. Structures can be used, reused, and nested in many ways. This allows for efficient data reuse and arbitrary complexity.</p></li></ul><h2 id="Design-goals" tabindex="-1">Design goals <a class="header-anchor" href="#Design-goals" aria-label="Permalink to &quot;Design goals {#Design-goals}&quot;">​</a></h2><p>This philosophy has three primary goals:</p><h3 id="1.-Maintainability-and-expandability" tabindex="-1">1. Maintainability and expandability <a class="header-anchor" href="#1.-Maintainability-and-expandability" aria-label="Permalink to &quot;1. Maintainability and expandability {#1.-Maintainability-and-expandability}&quot;">​</a></h3><ul><li><p>The only way to break existing functionality should be by modifying APIs.</p></li><li><p>Adding functionality should be a case of subtyping existing abstract types and implementing the correct interfaces.</p></li><li><p>Avoid leaking side effects to other components unless completely necessary. An example of this is entropy pooling requiring the use of a vector of observation weights which must be taken into account in different, largely unrelated places.</p></li></ul><h3 id="2.-Correctness-and-robustness" tabindex="-1">2. Correctness and robustness <a class="header-anchor" href="#2.-Correctness-and-robustness" aria-label="Permalink to &quot;2. Correctness and robustness {#2.-Correctness-and-robustness}&quot;">​</a></h3><ul><li>Each subunit should perform its own data validation as early as possible unless it absolutely needs downstream data.</li></ul><h3 id="3.-Performance" tabindex="-1">3. Performance <a class="header-anchor" href="#3.-Performance" aria-label="Permalink to &quot;3. Performance {#3.-Performance}&quot;">​</a></h3><ul><li><p>Types and constants are always fully known at inference time.</p></li><li><p>Immutability ensures smaller structs live in the stack.</p></li></ul><h2 id="Contents" tabindex="-1">Contents <a class="header-anchor" href="#Contents" aria-label="Permalink to &quot;Contents {#Contents}&quot;">​</a></h2><ul><li><a href="./01_Base#base">Base</a></li><li><a href="./02_Tools#tools">Tools</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Except for a few cases, most of which are convenience function overloads. This means some links do not go to the exact method definition. Other than hard-coding links to specific lines of code, which is fragile, I haven&#39;t found an easy solution. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>',22)])])}const f=a(o,[["render",s]]);export{u as __pageData,f as default};
