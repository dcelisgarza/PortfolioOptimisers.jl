<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Direct Bubble Hierarchy Tree · PortfolioOptimisers.jl</title><meta name="title" content="Direct Bubble Hierarchy Tree · PortfolioOptimisers.jl"/><meta property="og:title" content="Direct Bubble Hierarchy Tree · PortfolioOptimisers.jl"/><meta property="twitter:title" content="Direct Bubble Hierarchy Tree · PortfolioOptimisers.jl"/><meta name="description" content="Documentation for PortfolioOptimisers.jl."/><meta property="og:description" content="Documentation for PortfolioOptimisers.jl."/><meta property="twitter:description" content="Documentation for PortfolioOptimisers.jl."/><meta property="og:url" content="https://dcelisgarza.github.io/PortfolioOptimisers.jl/011-4-Phylogeny/"/><meta property="twitter:url" content="https://dcelisgarza.github.io/PortfolioOptimisers.jl/011-4-Phylogeny/"/><link rel="canonical" href="https://dcelisgarza.github.io/PortfolioOptimisers.jl/011-4-Phylogeny/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="PortfolioOptimisers.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PortfolioOptimisers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">PortfolioOptimisers</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/1-Getting-Started/">Example 1: Simple <code>MeanRisk</code> optimisation</a></li><li><a class="tocitem" href="../examples/2-Mean-Risk-Objectives/">Example 2: <code>MeanRisk</code> objectives</a></li><li><a class="tocitem" href="../examples/3-Efficient-Frontier/">Example 3: Efficient frontier</a></li><li><a class="tocitem" href="../examples/4-Pareto-Surface/">Example 4: Pareto surface</a></li><li><a class="tocitem" href="../examples/5-Budget-Constraints/">Example 5: Budget constraints</a></li></ul></li><li><a class="tocitem" href="../090-contributing/">Contributing guidelines</a></li><li><a class="tocitem" href="../091-developer/">Developer documentation</a></li><li><a class="tocitem" href="../092-reference/">Reference</a></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../001-Base/">Base</a></li><li><a class="tocitem" href="../002-Tools/">Tools</a></li><li><a class="tocitem" href="../003-PosdefMatrix/">PosdefMatrix</a></li><li><a class="tocitem" href="../004-Denoise/">Denoise</a></li><li><a class="tocitem" href="../005-Detone/">Detone</a></li><li><a class="tocitem" href="../006-MatrixProcessing/">Matrix Processing</a></li><li><input class="collapse-toggle" id="menuitem-6-7" type="checkbox"/><label class="tocitem" for="menuitem-6-7"><span class="docs-label">Moments</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../007-01-Moments/">Base Moments</a></li><li><a class="tocitem" href="../007-02-Moments/">Mean</a></li><li><a class="tocitem" href="../007-03-Moments/">Covariance</a></li><li><a class="tocitem" href="../007-04-Moments/">Variance and Standard Deviation</a></li><li><a class="tocitem" href="../007-05-Moments/">Gerber Covariance</a></li><li><a class="tocitem" href="../007-06-Moments/">Smyth-Broby Covariance</a></li><li><a class="tocitem" href="../007-07-Moments/">Distance Covariance</a></li><li><a class="tocitem" href="../007-08-Moments/">Lower Tail Dependence Covariance</a></li><li><a class="tocitem" href="../007-09-Moments/">Rank Covariances</a></li><li><a class="tocitem" href="../007-10-Moments/">Histogram</a></li><li><a class="tocitem" href="../007-11-Moments/">Mutual Information Covariance</a></li><li><a class="tocitem" href="../007-12-Moments/">PortfolioOptimisersCovariance</a></li><li><a class="tocitem" href="../007-13-Moments/">Shrunk Expected Returns</a></li><li><a class="tocitem" href="../007-14-Moments/">Equilibrium expected returns</a></li><li><a class="tocitem" href="../007-15-Moments/">Excess expected returns</a></li><li><a class="tocitem" href="../007-16-Moments/">Coskewness</a></li><li><a class="tocitem" href="../007-17-Moments/">Cokurtosis</a></li><li><a class="tocitem" href="../007-18-Moments/">Regression</a></li><li><a class="tocitem" href="../007-19-Moments/">Stepwise Regression</a></li><li><a class="tocitem" href="../007-20-Moments/">Dimensional Reduction Regression</a></li><li><a class="tocitem" href="../007-21-Moments/">Implied Volatility</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-8" type="checkbox"/><label class="tocitem" for="menuitem-6-8"><span class="docs-label">Distance</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../008-1-Distance/">Base Distance</a></li><li><a class="tocitem" href="../008-2-Distance/">Distance</a></li><li><a class="tocitem" href="../008-3-Distance/">Distances of Distances</a></li><li><a class="tocitem" href="../008-4-Distance/">General Distance</a></li><li><a class="tocitem" href="../008-5-Distance/">General Distance of Distances</a></li></ul></li><li><a class="tocitem" href="../009-JuMPModelOptimisation/">JuMP Model Optimisation</a></li><li><a class="tocitem" href="../010-OWA/">Ordered Weights Array</a></li><li><input class="collapse-toggle" id="menuitem-6-11" type="checkbox" checked/><label class="tocitem" for="menuitem-6-11"><span class="docs-label">Phylogeny</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../011-1-Phylogeny/">Base Phylogeny</a></li><li><a class="tocitem" href="../011-2-Phylogeny/">Clustering</a></li><li><a class="tocitem" href="../011-3-Phylogeny/">Hierarchical</a></li><li class="is-active"><a class="tocitem" href>Direct Bubble Hierarchy Tree</a></li><li><a class="tocitem" href="../011-5-Phylogeny/">Phylogeny</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-12" type="checkbox"/><label class="tocitem" for="menuitem-6-12"><span class="docs-label">Constraint Generation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../012-1-ConstraintGeneration/">Base Constraint Generation</a></li><li><a class="tocitem" href="../012-2-ConstraintGeneration/">Linear Constraints</a></li><li><a class="tocitem" href="../012-3-ConstraintGeneration/">Phylogeny Constraints</a></li><li><a class="tocitem" href="../012-4-ConstraintGeneration/">Weight Bounds</a></li><li><a class="tocitem" href="../012-5-ConstraintGeneration/">Buy-in Threshold Constraints</a></li></ul></li><li><a class="tocitem" href="../013-10-Prior/">Prior</a></li><li><a class="tocitem" href="../019-15-Optimisation/">Optimisation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li><a class="is-disabled">Phylogeny</a></li><li class="is-active"><a href>Direct Bubble Hierarchy Tree</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Direct Bubble Hierarchy Tree</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/main/docs/src/011-4-Phylogeny.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Direct-Bubble-Hierarchy-Tree"><a class="docs-heading-anchor" href="#Direct-Bubble-Hierarchy-Tree">Direct Bubble Hierarchy Tree</a><a id="Direct-Bubble-Hierarchy-Tree-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-Bubble-Hierarchy-Tree" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.UniqueRoot" href="#PortfolioOptimisers.UniqueRoot"><code>PortfolioOptimisers.UniqueRoot</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct UniqueRoot &lt;: DBHTRootMethod end</code></pre><p>A DBHT root selection method that enforces a unique root in the hierarchy.</p><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.DBHTRootMethod"><code>DBHTRootMethod</code></a></li><li><a href="#PortfolioOptimisers.EqualRoot"><code>EqualRoot</code></a></li><li><a href="#PortfolioOptimisers.DBHT"><code>DBHT</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L16-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.EqualRoot" href="#PortfolioOptimisers.EqualRoot"><code>PortfolioOptimisers.EqualRoot</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct EqualRoot &lt;: DBHTRootMethod end</code></pre><p>A DBHT root selection method that creates a root from the adjacency tree of all root candidates. This can be used to represent multiple equally plausible roots in the DBHT hierarchy.</p><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.DBHTRootMethod"><code>DBHTRootMethod</code></a></li><li><a href="#PortfolioOptimisers.UniqueRoot"><code>UniqueRoot</code></a></li><li><a href="#PortfolioOptimisers.DBHT"><code>DBHT</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L31-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.MaximumDistanceSimilarity" href="#PortfolioOptimisers.MaximumDistanceSimilarity"><code>PortfolioOptimisers.MaximumDistanceSimilarity</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct MaximumDistanceSimilarity &lt;: AbstractSimilarityMatrixAlgorithm end</code></pre><p>Similarity matrix algorithm using the maximum distance transformation.</p><p class="math-container">\[\begin{align}
S_{i,\,j} &amp;= \left\lceil\max(\mathbf{D})^2\right\rceil - D_{i,\,j}^2\,,
\end{align}\]</p><p>where <code>S</code> is the similarity, <code>\mathbf{D}</code> the distance matrix, and each subscript denotes an asset.</p><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.AbstractSimilarityMatrixAlgorithm"><code>AbstractSimilarityMatrixAlgorithm</code></a></li><li><a href="#PortfolioOptimisers.ExponentialSimilarity"><code>ExponentialSimilarity</code></a></li><li><a href="#PortfolioOptimisers.GeneralExponentialSimilarity"><code>GeneralExponentialSimilarity</code></a></li><li><a href="#PortfolioOptimisers.dbht_similarity"><code>dbht_similarity</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L63-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.ExponentialSimilarity" href="#PortfolioOptimisers.ExponentialSimilarity"><code>PortfolioOptimisers.ExponentialSimilarity</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ExponentialSimilarity &lt;: AbstractSimilarityMatrixAlgorithm end</code></pre><p>Similarity matrix algorithm using the exponential transformation.</p><p class="math-container">\[\begin{align}
S_{i,\,j} &amp;= e^{-D_{i,\,j}}\,,
\end{align}\]</p><p>where <code>S</code> is the similarity, <code>\mathbf{D}</code> the distance matrix, and each subscript denotes an asset.</p><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.AbstractSimilarityMatrixAlgorithm"><code>AbstractSimilarityMatrixAlgorithm</code></a></li><li><a href="#PortfolioOptimisers.MaximumDistanceSimilarity"><code>MaximumDistanceSimilarity</code></a></li><li><a href="#PortfolioOptimisers.GeneralExponentialSimilarity"><code>GeneralExponentialSimilarity</code></a></li><li><a href="#PortfolioOptimisers.dbht_similarity"><code>dbht_similarity</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L87-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.GeneralExponentialSimilarity" href="#PortfolioOptimisers.GeneralExponentialSimilarity"><code>PortfolioOptimisers.GeneralExponentialSimilarity</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GeneralExponentialSimilarity{T1, T2} &lt;: AbstractSimilarityMatrixAlgorithm
    coef::T1
    power::T2
end</code></pre><p>Similarity matrix algorithm using a generalised exponential transformation.</p><p class="math-container">\[\begin{align}
S_{i,\,j} &amp;= e^{-c \cdot D_{i,\,j}^p}\,,
\end{align}\]</p><p>where <code>S</code> is the similarity, <code>\mathbf{D}</code> the distance matrix, <span>$c$</span> a scale factor, <span>$p$</span> an exponent, and each subscript denotes an asset.</p><p><strong>Fields</strong></p><ul><li><code>coef</code>: Non-negative scaling coefficient.</li><li><code>power</code>: Non-negative exponent applied to the distance matrix.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">GeneralExponentialSimilarity(; coef::Real = 1.0, power::Real = 1.0)</code></pre><p>Keyword arguments correspond to the fields above.</p><p><strong>Validation</strong></p><ul><li><code>coef &gt;= 0</code>.</li><li><code>power &gt;= 0</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; GeneralExponentialSimilarity()
GeneralExponentialSimilarity
   coef | Float64: 1.0
  power | Float64: 1.0</code></pre><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.AbstractSimilarityMatrixAlgorithm"><code>AbstractSimilarityMatrixAlgorithm</code></a></li><li><a href="#PortfolioOptimisers.MaximumDistanceSimilarity"><code>MaximumDistanceSimilarity</code></a></li><li><a href="#PortfolioOptimisers.ExponentialSimilarity"><code>ExponentialSimilarity</code></a></li><li><a href="#PortfolioOptimisers.dbht_similarity"><code>dbht_similarity</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L111-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.DBHT" href="#PortfolioOptimisers.DBHT"><code>PortfolioOptimisers.DBHT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DBHT{T1, T2} &lt;: AbstractClusteringAlgorithm
    sim::T1
    root::T2
end</code></pre><p>Direct Bubble Hierarchical Tree (DBHT) clustering algorithm configuration.</p><p><code>DBHT</code> is a composable clustering algorithm type for constructing hierarchical clusterings using the Direct Bubble Hierarchical Tree (DBHT) method, as described in [<a href="../092-reference/#DBHTs">1</a>].</p><p><strong>Fields</strong></p><ul><li><code>sim</code>: Similarity matrix algorithm.</li><li><code>root</code>: Root selection method.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">DBHT(; sim::AbstractSimilarityMatrixAlgorithm = MaximumDistanceSimilarity(),
     root::DBHTRootMethod = UniqueRoot())</code></pre><p>Keyword arguments correspond to the fields above.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; DBHT()
DBHT
   sim | MaximumDistanceSimilarity()
  root | UniqueRoot()</code></pre><p><strong>Related</strong></p><ul><li><a href="../011-2-Phylogeny/#PortfolioOptimisers.AbstractClusteringAlgorithm"><code>AbstractClusteringAlgorithm</code></a></li><li><a href="#PortfolioOptimisers.AbstractSimilarityMatrixAlgorithm"><code>AbstractSimilarityMatrixAlgorithm</code></a></li><li><a href="#PortfolioOptimisers.DBHTRootMethod"><code>DBHTRootMethod</code></a></li><li><a href="#PortfolioOptimisers.MaximumDistanceSimilarity"><code>MaximumDistanceSimilarity</code></a></li><li><a href="#PortfolioOptimisers.ExponentialSimilarity"><code>ExponentialSimilarity</code></a></li><li><a href="#PortfolioOptimisers.GeneralExponentialSimilarity"><code>GeneralExponentialSimilarity</code></a></li><li><a href="#PortfolioOptimisers.UniqueRoot"><code>UniqueRoot</code></a></li><li><a href="#PortfolioOptimisers.EqualRoot"><code>EqualRoot</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L216-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.LoGo" href="#PortfolioOptimisers.LoGo"><code>PortfolioOptimisers.LoGo</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct LoGo{T1, T2} &lt;: InverseMatrixSparsificationAlgorithm
    dist::T1
    sim::T2
end</code></pre><p>LoGo (Local-Global) sparse inverse covariance estimation algorithm.</p><p><code>LoGo</code> is a composable algorithm type for estimating sparse inverse covariance matrices using the Planar Maximally Filtered Graph (PMFG) and clique-based decomposition, as described in [<a href="../092-reference/#J_LoGo">2</a>]. It combines a distance estimator and a similarity matrix algorithm, both validated and extensible, to produce a robust, interpretable sparse precision matrix for use in portfolio optimization and risk management.</p><p><strong>Fields</strong></p><ul><li><code>dist</code>: Distance matrix estimator.</li><li><code>sim</code>: Similarity matrix algorithm.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">LoGo(; dist::AbstractDistanceEstimator = Distance(; alg = CanonicalDistance()),
     sim::AbstractSimilarityMatrixAlgorithm = MaximumDistanceSimilarity())</code></pre><p>Keyword arguments correspond to the fields above.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; LoGo()
LoGo
  dist | Distance
       |   alg | CanonicalDistance()
   sim | MaximumDistanceSimilarity()</code></pre><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.InverseMatrixSparsificationAlgorithm"><code>InverseMatrixSparsificationAlgorithm</code></a></li><li><a href="../008-1-Distance/#PortfolioOptimisers.AbstractDistanceEstimator"><code>AbstractDistanceEstimator</code></a></li><li><a href="#PortfolioOptimisers.AbstractSimilarityMatrixAlgorithm"><code>AbstractSimilarityMatrixAlgorithm</code></a></li><li><a href="#PortfolioOptimisers.MaximumDistanceSimilarity"><code>MaximumDistanceSimilarity</code></a></li><li><a href="#PortfolioOptimisers.ExponentialSimilarity"><code>ExponentialSimilarity</code></a></li><li><a href="#PortfolioOptimisers.GeneralExponentialSimilarity"><code>GeneralExponentialSimilarity</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L1933-L1977">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.DBHTClustering" href="#PortfolioOptimisers.DBHTClustering"><code>PortfolioOptimisers.DBHTClustering</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct DBHTClustering{T1, T2, T3, T4} &lt;: AbstractClusteringResult
    clustering::T1
    S::T2
    D::T3
    k::T4
end</code></pre><p>Result type for Direct Bubble Hierarchical Tree (DBHT) clustering.</p><p><code>DBHTClustering</code> encapsulates the output of a DBHT clustering analysis, including the hierarchical clustering result, similarity and distance matrices, and the optimal number of clusters. This struct is returned by <a href="../011-2-Phylogeny/#PortfolioOptimisers.clusterise-Tuple{PortfolioOptimisers.AbstractClusteringResult, Vararg{Any}}"><code>clusterise</code></a> when using a DBHT-based clustering estimator.</p><p><strong>Fields</strong></p><ul><li><code>clustering</code>: Hierarchical clustering result, typically a <a href="https://juliastats.org/Clustering.jl/stable/hclust.html#Clustering.Hclust"><code>Clustering.Hclust</code></a> object.</li><li><code>S</code>: Similarity matrix used for DBHT clustering.</li><li><code>D</code>: Distance (dissimilarity) matrix used for DBHT clustering.</li><li><code>k</code>: Optimal number of clusters, as determined by the estimator&#39;s cluster selection method.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">DBHTClustering(; clustering::Clustering.Hclust, S::AbstractMatrix, D::AbstractMatrix,
               k::Integer)</code></pre><p>Keyword arguments correspond to the fields above.</p><p><strong>Validation</strong></p><ul><li><code>!isempty(S)</code></li><li><code>!isempty(D)</code></li><li><code>size(S) == size(D)</code></li><li><code>k &gt;= 1</code>.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.DBHT"><code>DBHT</code></a></li><li><a href="../011-2-Phylogeny/#PortfolioOptimisers.clusterise-Tuple{PortfolioOptimisers.AbstractClusteringResult, Vararg{Any}}"><code>clusterise</code></a></li><li><a href="https://juliastats.org/Clustering.jl/stable/hclust.html#Clustering.Hclust"><code>Clustering.Hclust</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L1812-L1854">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.clusterise-Tuple{ClusteringEstimator{&lt;:Any, &lt;:Any, &lt;:DBHT}, AbstractMatrix{&lt;:Real}}" href="#PortfolioOptimisers.clusterise-Tuple{ClusteringEstimator{&lt;:Any, &lt;:Any, &lt;:DBHT}, AbstractMatrix{&lt;:Real}}"><code>PortfolioOptimisers.clusterise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clusterise(cle::ClusteringEstimator{&lt;:Any, &lt;:Any, &lt;:DBHT, &lt;:Any}, X::AbstractMatrix{&lt;:Real};
           branchorder::Symbol = :optimal, dims::Int = 1, kwargs...)</code></pre><p>Perform Direct Bubble Hierarchical Tree (DBHT) clustering using a <code>ClusteringEstimator</code> configured with a <code>DBHT</code> algorithm.</p><p>This method computes the similarity and distance matrices from the input data matrix <code>X</code> using the estimator&#39;s configured estimators and algorithms, applies the DBHT clustering pipeline, and returns a <a href="#PortfolioOptimisers.DBHTClustering"><code>DBHTClustering</code></a> result containing the hierarchical clustering, similarity and distance matrices, and the optimal number of clusters.</p><p><strong>Arguments</strong></p><ul><li><code>cle</code>: A <code>ClusteringEstimator</code> whose algorithm is a <a href="#PortfolioOptimisers.DBHT"><code>DBHT</code></a> instance.</li><li><code>X</code>: Data matrix (<code>observations × assets</code> or <code>assets × observations</code> depending on <code>dims</code>).</li><li><code>branchorder</code>: Symbol specifying the dendrogram branch ordering method. Accepts <code>:optimal</code> (default), <code>:barjoseph</code>, or <code>:r</code>.</li><li><code>dims</code>: Integer specifying the dimension along which to compute statistics (<code>1</code> for columns/assets, <code>2</code> for rows).</li><li><code>kwargs...</code>: Additional keyword arguments passed to the underlying estimators.</li></ul><p><strong>Details</strong></p><ul><li>Computes the similarity and distance matrices using the estimator&#39;s configured correlation and distance estimators.</li><li>Applies the selected similarity transformation via <a href="#PortfolioOptimisers.dbht_similarity"><code>dbht_similarity</code></a>.</li><li>Runs the full DBHT clustering pipeline via <a href="#PortfolioOptimisers.DBHTs"><code>DBHTs</code></a>, including PMFG construction, clique and bubble hierarchy extraction, and dendrogram construction.</li><li>Determines the optimal number of clusters using the estimator&#39;s cluster selection method.</li><li>Returns a <a href="#PortfolioOptimisers.DBHTClustering"><code>DBHTClustering</code></a> result encapsulating all relevant outputs.</li></ul><p><strong>Returns</strong></p><ul><li><code>clr::DBHTClustering</code>: DBHT clustering result.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.DBHT"><code>DBHT</code></a></li><li><a href="#PortfolioOptimisers.DBHTClustering"><code>DBHTClustering</code></a></li><li><a href="#PortfolioOptimisers.DBHTs"><code>DBHTs</code></a></li><li><a href="#PortfolioOptimisers.dbht_similarity"><code>dbht_similarity</code></a></li><li><a href="../011-2-Phylogeny/#PortfolioOptimisers.ClusteringEstimator"><code>ClusteringEstimator</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L1868-L1905">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.DBHTRootMethod" href="#PortfolioOptimisers.DBHTRootMethod"><code>PortfolioOptimisers.DBHTRootMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type DBHTRootMethod &lt;: AbstractAlgorithm end</code></pre><p>Abstract supertype for all Direct Bubble Hierarchy Tree (DBHT) root selection methods in PortfolioOptimisers.jl.</p><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.UniqueRoot"><code>UniqueRoot</code></a></li><li><a href="#PortfolioOptimisers.EqualRoot"><code>EqualRoot</code></a></li><li><a href="#PortfolioOptimisers.DBHT"><code>DBHT</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.AbstractSimilarityMatrixAlgorithm" href="#PortfolioOptimisers.AbstractSimilarityMatrixAlgorithm"><code>PortfolioOptimisers.AbstractSimilarityMatrixAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractSimilarityMatrixAlgorithm &lt;: AbstractAlgorithm end</code></pre><p>Abstract supertype for all similarity matrix algorithms used in the creation of Planar Maximally Filtered Graph (PMFG) used in <a href="#PortfolioOptimisers.DBHT"><code>DBHT</code></a> and <a href="#PortfolioOptimisers.LoGo"><code>LoGo</code></a> methods.</p><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.MaximumDistanceSimilarity"><code>MaximumDistanceSimilarity</code></a></li><li><a href="#PortfolioOptimisers.ExponentialSimilarity"><code>ExponentialSimilarity</code></a></li><li><a href="#PortfolioOptimisers.GeneralExponentialSimilarity"><code>GeneralExponentialSimilarity</code></a></li><li><a href="#PortfolioOptimisers.DBHT"><code>DBHT</code></a></li><li><a href="#PortfolioOptimisers.LoGo"><code>LoGo</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L46-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.InverseMatrixSparsificationAlgorithm" href="#PortfolioOptimisers.InverseMatrixSparsificationAlgorithm"><code>PortfolioOptimisers.InverseMatrixSparsificationAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type InverseMatrixSparsificationAlgorithm &lt;: AbstractMatrixProcessingAlgorithm end</code></pre><p>Abstract supertype for all inverse matrix sparsification algorithms in PortfolioOptimisers.jl.</p><p><strong>Related</strong></p><ul><li><a href="../006-MatrixProcessing/#PortfolioOptimisers.AbstractMatrixProcessingAlgorithm"><code>AbstractMatrixProcessingAlgorithm</code></a></li><li><a href="#PortfolioOptimisers.LoGo"><code>LoGo</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L1919-L1930">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.PMFG_T2s" href="#PortfolioOptimisers.PMFG_T2s"><code>PortfolioOptimisers.PMFG_T2s</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PMFG_T2s(W::AbstractMatrix{&lt;:Real}; nargout::Integer = 3)</code></pre><p>Constructs a Triangulated Maximally Filtered Graph (TMFG) starting from a tetrahedron and recursively inserting vertices inside existing triangles (T2 move) in order to approximate a Maximal Planar Graph with the largest total weight, also known as the Planar Maximally Filtered Graph (PMFG). All weights must be non-negative.</p><p>This function is a core step in the DBHT (Direct Bubble Hierarchical Tree) and LoGo algorithms, providing the planar graph structure and clique information required for hierarchical clustering and sparse inverse covariance estimation.</p><p><strong>Arguments</strong></p><ul><li><code>W</code>: <code>N×N</code> matrix of non-negative weights (e.g., similarity or correlation matrix).</li><li><code>nargout</code>: Number of output arguments. All outputs are always computed, but if <code>nargout &lt;= 3</code>, <code>cliques</code> and <code>cliqueTree</code> are returned as <code>nothing</code>.</li></ul><p><strong>Validation</strong></p><ul><li><code>N &gt;= 9</code> is required for a meaningful PMFG.</li><li>All entries in <code>W</code> must be non-negative.</li></ul><p><strong>Details</strong></p><ul><li>The algorithm starts by selecting the four vertices with the largest strength to form an initial tetrahedron.</li><li>Vertices are recursively inserted into existing triangles to maximize the total weight, following the T2 move.</li><li>The resulting graph is planar and maximally filtered, preserving the most relevant connections for hierarchical clustering.</li><li>The function also identifies all 3-cliques and, optionally, all 4-cliques and their adjacency structure.</li></ul><p><strong>Returns</strong></p><ul><li><code>A::SparseMatrixCSC{&lt;:Real, Int}</code>: Adjacency matrix of the PMFG with weights.</li><li><code>tri::Matrix{Int}</code>: List of triangles (triangular faces) in the PMFG.</li><li><code>clique3::Matrix{Int}</code>: List of 3-cliques that are not triangular faces; all 3-cliques are given by <code>[tri; clique3]</code>.</li><li><code>cliques::Union{Nothing, Matrix{Int}}</code>: List of all 4-cliques (tetrahedra), or <code>nothing</code> if <code>nargout &lt;= 3</code>.</li><li><code>cliqueTree::Union{Nothing, SparseMatrixCSC{Int, Int}}</code>: 4-cliques tree structure (adjacency matrix), or <code>nothing</code> if <code>nargout &lt;= 4</code>.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>CliqHierarchyTree2s</code></a></li><li><a href="#PortfolioOptimisers.DBHT"><code>DBHT</code></a></li><li><a href="#PortfolioOptimisers.LoGo"><code>LoGo</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L271-L310">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.dbht_similarity" href="#PortfolioOptimisers.dbht_similarity"><code>PortfolioOptimisers.dbht_similarity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dbht_similarity(se::AbstractSimilarityMatrixAlgorithm; D::AbstractMatrix, kwargs...)</code></pre><p>Compute a similarity matrix from a distance matrix using the specified similarity algorithm.</p><p>This function dispatches on the type of <code>se</code> to apply the appropriate similarity transformation to the distance matrix <code>D</code>. Used internally by DBHT and related clustering algorithms.</p><p><strong>Arguments</strong></p><ul><li><p><code>se</code>: Similarity matrix algorithm.</p><ul><li><code>se::MaximumDistanceSimilarity</code>: Uses the maximum distance transformation.</li><li><code>se::ExponentialSimilarity</code>: Uses the exponential transformation.</li><li><code>se::GeneralExponentialSimilarity</code>: Uses a generalised exponential transformation.</li></ul></li><li><p><code>D</code>: Distance matrix.</p></li><li><p><code>kwargs...</code>: Additional keyword arguments (not used).</p></li></ul><p><strong>Returns</strong></p><ul><li><code>S::Matrix{&lt;:Real}</code>: Similarity matrix of the same size as <code>D</code>.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.AbstractSimilarityMatrixAlgorithm"><code>AbstractSimilarityMatrixAlgorithm</code></a></li><li><a href="#PortfolioOptimisers.MaximumDistanceSimilarity"><code>MaximumDistanceSimilarity</code></a></li><li><a href="#PortfolioOptimisers.ExponentialSimilarity"><code>ExponentialSimilarity</code></a></li><li><a href="#PortfolioOptimisers.GeneralExponentialSimilarity"><code>GeneralExponentialSimilarity</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L173-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.distance_wei" href="#PortfolioOptimisers.distance_wei"><code>PortfolioOptimisers.distance_wei</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance_wei(L::AbstractMatrix{&lt;:Real})</code></pre><p>Compute the shortest weighted path lengths between all node pairs in a network.</p><p>This function computes the distance matrix containing the lengths of the shortest paths between all node pairs in a (possibly weighted) network, using Dijkstra&#39;s algorithm. An entry <code>[u, v]</code> represents the length of the shortest path from node <code>u</code> to node <code>v</code>. The average shortest path length is the characteristic path length of the network.</p><p><strong>Inputs</strong></p><ul><li><p><code>L</code>: Directed or undirected connection-length matrix.</p><ul><li>Lengths between disconnected nodes should be set to <code>Inf</code>.</li><li>Lengths on the main diagonal should be set to <code>0</code>.</li></ul></li></ul><div class="admonition is-info" id="Note-f83f56171419a716"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-f83f56171419a716" title="Permalink"></a></header><div class="admonition-body"><p>The input matrix must be a connection-length matrix, typically obtained by mapping weights to lengths (e.g., inverse of a similarity or correlation matrix). In weighted networks, shortest weighted paths may traverse more edges than shortest binary paths.</p></div></div><p><strong>Details</strong></p><ul><li>For each node, the function computes the shortest path to all other nodes using Dijkstra&#39;s algorithm.</li><li>The output <code>D</code> contains the minimal total length for each node pair, and <code>B</code> contains the number of edges in the corresponding shortest path.</li><li>Used internally for PMFG and DBHT clustering to compute geodesic distances on the graph.</li></ul><p><strong>Returns</strong></p><ul><li><code>D::Matrix{&lt;:Real}</code>: Distance (shortest weighted path) matrix.</li><li><code>B::Matrix{Int}</code>: Number of edges in the shortest weighted path matrix.</li></ul><div class="admonition is-info" id="Note-106deab4ca20a1e"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-106deab4ca20a1e" title="Permalink"></a></header><div class="admonition-body"><p>Based on a Matlab implementation by Mika Rubinov, Rick Betzel, and Andrea Avena.</p></div></div><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.PMFG_T2s"><code>PMFG_T2s</code></a></li><li><a href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>CliqHierarchyTree2s</code></a></li><li><a href="#PortfolioOptimisers.DBHT"><code>DBHT</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L412-L452">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.clique3" href="#PortfolioOptimisers.clique3"><code>PortfolioOptimisers.clique3</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clique3(A::AbstractMatrix{&lt;:Real})</code></pre><p>Computes the list of 3-cliques in a Maximal Planar Graph (MPG).</p><p>This function identifies all 3-cliques (triangles) in the adjacency matrix <code>A</code> of a MPG. It returns the candidate cliques, their edge indices, and a matrix listing all unique 3-cliques. Used internally in DBHT and related phylogenetic clustering algorithms.</p><p><strong>Inputs</strong></p><ul><li><code>A</code>: <code>N×N</code> adjacency matrix of a Maximal Planar Graph (MPG).</li></ul><p><strong>Details</strong></p><ul><li>The function searches for all triangles (3-cliques) by examining pairs of connected nodes and their shared neighbors.</li><li>Duplicates are removed and the resulting list is sorted for consistency.</li><li>The output <code>clique</code> matrix is used as the basis for further hierarchical and bubble structure construction in DBHT.</li></ul><p><strong>Returns</strong></p><ul><li><code>K3::Vector{Vector{Int}}</code>: Vector of vectors, each containing the indices of nodes forming a candidate 3-clique.</li><li><code>E::Matrix{Int}</code>: Matrix with nonzero indices and entries of candidate cliques (edge pairs).</li><li><code>clique::Matrix{Int}</code>: <code>Nc×3</code> matrix. Each row lists the three vertices of a unique 3-clique in the MPG.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>CliqHierarchyTree2s</code></a></li><li><a href="#PortfolioOptimisers.BubbleHierarchy"><code>BubbleHierarchy</code></a></li><li><a href="#PortfolioOptimisers.DBHT"><code>DBHT</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L493-L523">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.breadth" href="#PortfolioOptimisers.breadth"><code>PortfolioOptimisers.breadth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">breadth(CIJ::AbstractMatrix{&lt;:Real}, source::Integer)</code></pre><p>Breadth-first search.</p><p>This function performs a breadth-first search (BFS) on a binary (directed or undirected) connection matrix, starting from a specified source vertex. It computes the shortest path distances from the source to all other vertices and records the predecessor (branch) for each node in the BFS tree.</p><p><strong>Inputs</strong></p><ul><li><code>CIJ</code>: Binary (0/1) connection matrix representing the graph.</li><li><code>source</code>: Index of the source vertex from which to start the search.</li></ul><p><strong>Returns</strong></p><ul><li><code>distance::Vector{&lt;:Real}</code>: Vector of shortest path distances from the source to each vertex (<code>0</code> for the source itself, <code>Inf</code> for unreachable nodes).</li><li><code>branch::Vector{Int}</code>: Vector of predecessor indices for each vertex in the BFS tree (<code>-1</code> for the source).</li></ul><p><strong>Details</strong></p><ul><li>The function explores the entire graph, layer by layer, starting from the source vertex.</li><li>For each node, it records the minimum number of steps required to reach it from the source.</li><li>The <code>branch</code> vector allows reconstruction of the BFS tree.</li><li>Used internally for component analysis and separating set identification in DBHT and related algorithms.</li></ul><p><strong>Notes</strong></p><ul><li>The BFS tree does not contain all paths (or all shortest paths), but allows the determination of at least one path with minimum distance.</li><li>Original implementation by Olaf Sporns, Indiana University, 2002/2007/2008.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.FindDisjoint"><code>FindDisjoint</code></a></li><li><a href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>CliqHierarchyTree2s</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L571-L606">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.FindDisjoint" href="#PortfolioOptimisers.FindDisjoint"><code>PortfolioOptimisers.FindDisjoint</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FindDisjoint(Adj::AbstractMatrix{&lt;:Real}, Cliq::AbstractVector{&lt;:Real})</code></pre><p>Finds disjointed cliques in an adjacency matrix.</p><p>This function identifies nodes that are not adjacent to a given 3-clique in the adjacency matrix, and classifies all nodes into three groups: members of the clique, nodes in the same connected component as the clique, and nodes in a disjoint component.</p><p><strong>Arguments</strong></p><ul><li><code>Adj</code>: <code>N×N</code> adjacency matrix.</li><li><code>Cliq</code>: <code>3×1</code> vector of node indices forming a 3-clique.</li></ul><p><strong>Details</strong></p><ul><li>The function removes the clique nodes from the adjacency matrix and performs a breadth-first search to classify the remaining nodes.</li><li>Nodes unreachable from the first non-clique node are marked as disjoint.</li><li>Used internally by DBHT routines to determine separating sets and clique membership.</li></ul><p><strong>Returns</strong></p><ul><li><p><code>T::Vector{Int}</code>: <code>N×1</code> vector containing the adjacency number of each node:</p><ul><li><code>0</code> for nodes in the clique,</li><li><code>1</code> for nodes in a disjoint component,</li><li><code>2</code> for nodes in the same component as the clique.</li></ul></li><li><p><code>IndxNot::Vector{Int}</code>: <code>N×1</code> vector of nodes with no adjacencies to the clique.</p></li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.breadth"><code>breadth</code></a></li><li><a href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>CliqHierarchyTree2s</code></a></li><li><a href="#PortfolioOptimisers.BubbleHierarchy"><code>BubbleHierarchy</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L647-L682">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.BuildHierarchy" href="#PortfolioOptimisers.BuildHierarchy"><code>PortfolioOptimisers.BuildHierarchy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BuildHierarchy(M::AbstractMatrix{&lt;:Real})</code></pre><p>Builds the predicted parent hierarchy for 3-cliques in a Maximal Planar Graph (MPG).</p><p>This function constructs the parent index vector (<code>Pred</code>) for each 3-clique, given the node-to-clique membership matrix <code>M</code>. It is a core step in the DBHT (Direct Bubble Hierarchical Tree) clustering pipeline, enabling the construction of the clique hierarchy tree.</p><p><strong>Arguments</strong></p><ul><li><code>M</code>: <code>N×Nc</code> binary matrix of node-to-3-clique memberships, where <code>M[i, n] = 1</code> if node <code>i</code> belongs to 3-clique <code>n</code>.</li></ul><p><strong>Details</strong></p><ul><li>For each 3-clique, the function identifies its parent clique as the smallest superset among all cliques containing its nodes.</li><li>If multiple parent candidates exist, the one with the smallest overlap is chosen.</li><li>Root cliques (with no parent) are assigned a parent index of <code>0</code>.</li><li>Used internally by <a href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>CliqHierarchyTree2s</code></a> and DBHT clustering routines.</li></ul><p><strong>Returns</strong></p><ul><li><code>Pred::Vector{Int}</code>: <code>Nc×1</code> vector of predicted parent indices for each 3-clique. <code>Pred[n] = 0</code> indicates a root clique.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>CliqHierarchyTree2s</code></a></li><li><a href="#PortfolioOptimisers.BubbleHierarchy"><code>BubbleHierarchy</code></a></li><li><a href="#PortfolioOptimisers.DBHT"><code>DBHT</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L705-L734">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.AdjCliq" href="#PortfolioOptimisers.AdjCliq"><code>PortfolioOptimisers.AdjCliq</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdjCliq(A::AbstractMatrix{&lt;:Real}, CliqList::AbstractMatrix{&lt;:Real},
        CliqRoot::AbstractVector{&lt;:Real})</code></pre><p>Find adjacent cliques to the root candidates in a Maximal Planar Graph (MPG).</p><p>This function computes the adjacency matrix among root candidate 3-cliques, identifying which root cliques are adjacent (i.e., share two vertices) in the graph. Used internally by <a href="#PortfolioOptimisers.CliqueRoot"><code>CliqueRoot</code></a> with <a href="#PortfolioOptimisers.EqualRoot"><code>EqualRoot</code></a> to construct a root from the adjacency tree of all root candidates.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: <code>N×N</code> adjacency matrix of the MPG.</li><li><code>CliqList</code>: <code>Nc×3</code> matrix. Each row lists the three vertices of a 3-clique in the MPG.</li><li><code>CliqRoot</code>: Vector of indices of root candidate cliques.</li></ul><p><strong>Details</strong></p><ul><li>For each root candidate clique, the function checks which other root cliques share exactly two vertices (i.e., are adjacent in the clique graph).</li><li>The resulting adjacency matrix is symmetric and encodes the adjacency structure among root cliques.</li><li>Used to build a connected root structure when multiple root candidates exist in the DBHT hierarchy.</li></ul><p><strong>Returns</strong></p><ul><li><code>Adj::SparseMatrixCSC{Int, Int}</code>: <code>Nc×Nc</code> adjacency matrix of the cliques, where <code>Adj[i, j] = 1</code> if cliques <code>i</code> and <code>j</code> are adjacent among the root candidates.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.CliqueRoot"><code>CliqueRoot</code></a></li><li><a href="#PortfolioOptimisers.EqualRoot"><code>EqualRoot</code></a></li><li><a href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>CliqHierarchyTree2s</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L755-L786">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.BubbleHierarchy" href="#PortfolioOptimisers.BubbleHierarchy"><code>PortfolioOptimisers.BubbleHierarchy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BubbleHierarchy(Pred::AbstractVector{&lt;:Real}, Sb::AbstractVector{&lt;:Real})</code></pre><p>Build the bubble hierarchy from the clique hierarchy and separating set information.</p><p>This function constructs the bubble hierarchy tree and the bubble membership matrix for 3-cliques, given the predicted parent indices (<code>Pred</code>) and separating set vector (<code>Sb</code>). It is a core step in the DBHT (Direct Bubble Hierarchical Tree) clustering pipeline, grouping 3-cliques into bubbles and building the adjacency structure among bubbles.</p><p><strong>Arguments</strong></p><ul><li><code>Pred</code>: <code>Nc×1</code> vector of predicted parent indices for each 3-clique, as returned by <a href="#PortfolioOptimisers.BuildHierarchy"><code>BuildHierarchy</code></a>.</li><li><code>Sb</code>: <code>Nc×1</code> vector indicating the size of the separating set for each 3-clique (<code>Sb[n] ≠ 0</code> means clique <code>n</code> is separating).</li></ul><p><strong>Details</strong></p><ul><li>The function iteratively groups 3-cliques into bubbles, starting from root cliques and traversing the hierarchy.</li><li>For each bubble, the membership of 3-cliques is recorded in <code>Mb</code>.</li><li>The adjacency matrix <code>H</code> encodes the connections between bubbles, based on shared membership and hierarchical relationships.</li><li>If there are multiple root cliques, an initial bubble is created for each root.</li><li>Used internally by <a href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>CliqHierarchyTree2s</code></a> and DBHT clustering routines.</li></ul><p><strong>Returns</strong></p><ul><li><code>H::SparseMatrixCSC{Int, Int}</code>: <code>Nb×Nb</code> symmetric adjacency matrix representing the bubble hierarchy tree, where <code>Nb</code> is the number of bubbles.</li><li><code>Mb::Matrix{Int}</code>: <code>Nc×Nb</code> bubble membership matrix for 3-cliques. <code>Mb[n, bi] = 1</code> indicates that 3-clique <code>n</code> belongs to bubble <code>bi</code>.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.BuildHierarchy"><code>BuildHierarchy</code></a></li><li><a href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>CliqHierarchyTree2s</code></a></li><li><a href="#PortfolioOptimisers.DBHT"><code>DBHT</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L806-L838">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.CliqueRoot" href="#PortfolioOptimisers.CliqueRoot"><code>PortfolioOptimisers.CliqueRoot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CliqueRoot(::UniqueRoot, Root::AbstractVector, Pred::AbstractVector, Nc::Integer, args...)</code></pre><p>Construct the hierarchical adjacency matrix for 3-cliques in a Maximal Planar Graph (MPG) using the unique root selection method.</p><p>This method enforces a unique root in the clique hierarchy. If multiple root candidates are present, a synthetic root is created and all root candidates are attached to it. Used internally by <a href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>CliqHierarchyTree2s</code></a> when the root selection method is <a href="#PortfolioOptimisers.UniqueRoot"><code>UniqueRoot</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>::UniqueRoot</code>: Root selection method enforcing a unique root.</li><li><code>Root</code>: Vector of indices of root candidate cliques.</li><li><code>Pred</code>: Vector of predicted parent indices for each clique.</li><li><code>Nc</code>: Number of 3-cliques.</li><li><code>args...</code>: Additional arguments (ignored for this method).</li></ul><p><strong>Details</strong></p><ul><li>If there is more than one root candidate, a synthetic root node is appended and all root candidates are connected to it.</li><li>The resulting matrix encodes the parent-child relationships among cliques, ensuring a single connected hierarchy.</li><li>Used internally by DBHT clustering and related routines.</li></ul><p><strong>Returns</strong></p><ul><li><code>H::SparseMatrixCSC{Int, Int}</code>: Symmetric adjacency matrix representing the hierarchical tree of 3-cliques.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.DBHTRootMethod"><code>DBHTRootMethod</code></a></li><li><a href="#PortfolioOptimisers.UniqueRoot"><code>UniqueRoot</code></a></li><li><a href="#PortfolioOptimisers.CliqueRoot"><code>CliqueRoot</code></a></li><li><a href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>CliqHierarchyTree2s</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L884-L917">source</a></section><section><div><pre><code class="language-julia hljs">CliqueRoot(::EqualRoot, Root::AbstractVector, Pred::AbstractVector, Nc::Integer,
           A::AbstractMatrix{&lt;:Real}, CliqList::AbstractMatrix{&lt;:Real})</code></pre><p>Construct the hierarchical adjacency matrix for 3-cliques in a Maximal Planar Graph (MPG) using the equal root selection method.</p><p>This method creates a root from the adjacency tree of all root candidate cliques, allowing for multiple equally plausible roots in the DBHT hierarchy. It is used internally by <a href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>CliqHierarchyTree2s</code></a> when the root selection method is <a href="#PortfolioOptimisers.EqualRoot"><code>EqualRoot</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>::EqualRoot</code>: Root selection method that creates a root from the adjacency tree of all root candidates.</li><li><code>Root</code>: Vector of indices of root candidate cliques.</li><li><code>Pred</code>: Vector of predicted parent indices for each clique.</li><li><code>Nc</code>: Number of 3-cliques.</li><li><code>A</code>: <code>N×N</code> adjacency matrix of the MPG.</li><li><code>CliqList</code>: <code>Nc×3</code> matrix. Each row vector lists the three vertices consisting of a 3-clique in the MPG.</li></ul><p><strong>Details</strong></p><ul><li>If there are multiple root candidates, their adjacency structure is computed using <a href="#PortfolioOptimisers.AdjCliq"><code>AdjCliq</code></a> and incorporated into the hierarchy.</li><li>The resulting matrix encodes both the parent-child relationships from <code>Pred</code> and the adjacency among root cliques.</li><li>Used internally by DBHT clustering to support alternative root strategies.</li></ul><p><strong>Returns</strong></p><ul><li><code>H::SparseMatrixCSC{Int, Int}</code>: Symmetric adjacency matrix representing the hierarchical tree of 3-cliques.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.DBHTRootMethod"><code>DBHTRootMethod</code></a></li><li><a href="#PortfolioOptimisers.EqualRoot"><code>EqualRoot</code></a></li><li><a href="#PortfolioOptimisers.CliqueRoot"><code>CliqueRoot</code></a></li><li><a href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>CliqHierarchyTree2s</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L934-L969">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.CliqHierarchyTree2s" href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>PortfolioOptimisers.CliqHierarchyTree2s</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CliqHierarchyTree2s(Apm::AbstractMatrix{&lt;:Real}; root::DBHTRootMethod = UniqueRoot())</code></pre><p>Construct the clique and bubble hierarchy trees for a Maximal Planar Graph (MPG) using the DBHT (Direct Bubble Hierarchical Tree) approach.</p><p>This function builds the hierarchical structure of 3-cliques (triangles) and bubbles from the adjacency matrix of a planar graph, supporting different root selection strategies via the <code>root</code> argument. It is a core routine for DBHT clustering and related phylogenetic analyses.</p><p><strong>Arguments</strong></p><ul><li><code>Apm::AbstractMatrix{&lt;:Real}</code>: Adjacency matrix of the MPG, where nonzero entries indicate edges.</li><li><code>root::DBHTRootMethod</code>: Root selection method for the clique hierarchy.</li></ul><p><strong>Details</strong></p><ul><li>The function first identifies all 3-cliques in the graph and computes their separating sets.</li><li>It then builds the clique hierarchy using the specified root selection method.</li><li>The bubble hierarchy is constructed from the clique hierarchy and separating sets.</li><li>Used internally by DBHT clustering and for extracting hierarchical structures from planar graphs.</li></ul><p><strong>Returns</strong></p><ul><li><code>H::SparseMatrixCSC{Int, Int}</code>: Symmetric adjacency matrix representing the hierarchical tree of 3-cliques.</li><li><code>H2::SparseMatrixCSC{Int, Int}</code>: Symmetric adjacency matrix representing the bubble hierarchy tree.</li><li><code>Mb::Matrix{Int}</code>: Bubble membership matrix for 3-cliques (<code>Nc×Nb</code>), where <code>Mb[n, bi] = 1</code> indicates 3-clique <code>n</code> belongs to bubble <code>bi</code>.</li><li><code>CliqList::Matrix{Int}</code>: List of 3-cliques (<code>Nc×3</code>), each row contains the vertex indices of a 3-clique.</li><li><code>Sb::Vector{Int}</code>: Vector indicating the size of the separating set for each 3-clique.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.DBHTRootMethod"><code>DBHTRootMethod</code></a></li><li><a href="#PortfolioOptimisers.UniqueRoot"><code>UniqueRoot</code></a></li><li><a href="#PortfolioOptimisers.EqualRoot"><code>EqualRoot</code></a></li><li><a href="#PortfolioOptimisers.DBHT"><code>DBHT</code></a></li><li><a href="#PortfolioOptimisers.PMFG_T2s"><code>PMFG_T2s</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L991-L1027">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.DirectHb" href="#PortfolioOptimisers.DirectHb"><code>PortfolioOptimisers.DirectHb</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DirectHb(Rpm::AbstractMatrix{&lt;:Real}, Hb::AbstractMatrix{&lt;:Real},
         Mb::AbstractMatrix{&lt;:Real}, Mv::AbstractMatrix{&lt;:Real},
         CliqList::AbstractMatrix{&lt;:Real})</code></pre><p>Compute the directed bubble hierarchy tree (DBHT) for a Maximal Planar Graph (MPG).</p><p>This function assigns directions to each separating 3-clique in the undirected bubble tree of a Planar Maximally Filtered Graph (PMFG), producing the directed bubble hierarchy tree (DBHT). The direction is determined by comparing the sum of edge weights on either side of each separating clique, enabling the identification of converging and diverging bubbles.</p><p><strong>Arguments</strong></p><ul><li><code>Rpm::AbstractMatrix{&lt;:Real}</code>: <code>N×N</code> sparse weighted adjacency matrix of the PMFG.</li><li><code>Hb::AbstractMatrix{&lt;:Real}</code>: Undirected bubble tree of the PMFG (as from <a href="#PortfolioOptimisers.BubbleHierarchy"><code>BubbleHierarchy</code></a>).</li><li><code>Mb::AbstractMatrix{&lt;:Real}</code>: <code>Nc×Nb</code> bubble membership matrix for 3-cliques. <code>Mb[n, bi] = 1</code> indicates 3-clique <code>n</code> belongs to bubble <code>bi</code>.</li><li><code>Mv::AbstractMatrix{&lt;:Real}</code>: <code>N×Nb</code> bubble membership matrix for vertices. <code>Mv[n, bi] = 1</code> means vertex <code>n</code> is a vertex of bubble <code>bi</code>.</li><li><code>CliqList::AbstractMatrix{&lt;:Real}</code>: <code>Nc×3</code> matrix. Each row lists the three vertices of a 3-clique in the MPG.</li></ul><p><strong>Details</strong></p><ul><li>For each edge in the undirected bubble tree, the function determines the direction by removing the edge and comparing the sum of edge weights for the separating clique on each side.</li><li>The resulting directed tree encodes the flow of hierarchical structure among bubbles, which is used for cluster assignment and further phylogenetic analysis.</li><li>Used internally by <a href="#PortfolioOptimisers.BubbleCluster8s"><code>BubbleCluster8s</code></a> and DBHT clustering routines.</li></ul><p><strong>Returns</strong></p><ul><li><code>Hc::SparseMatrixCSC{Real, Int}</code>: <code>Nb×Nb</code> unweighted directed adjacency matrix of the DBHT. <code>Hc[i, j] = 1</code> indicates a directed edge from bubble <code>i</code> to bubble <code>j</code>.</li><li><code>Sep::Vector{Int}</code>: Vector indicating the type of each bubble (e.g., converging, diverging, or neutral).</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.BubbleHierarchy"><code>BubbleHierarchy</code></a></li><li><a href="#PortfolioOptimisers.BubbleCluster8s"><code>BubbleCluster8s</code></a></li><li><a href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>CliqHierarchyTree2s</code></a></li><li><a href="#PortfolioOptimisers.DBHT"><code>DBHT</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L1070-L1106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.BubbleCluster8s" href="#PortfolioOptimisers.BubbleCluster8s"><code>PortfolioOptimisers.BubbleCluster8s</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BubbleCluster8s(Rpm::AbstractMatrix{&lt;:Real}, Dpm::AbstractMatrix{&lt;:Real},
                Hb::AbstractMatrix{&lt;:Real}, Mb::AbstractMatrix{&lt;:Real},
                Mv::AbstractMatrix{&lt;:Real}, CliqList::AbstractMatrix{&lt;:Real})</code></pre><p>Obtain non-discrete and discrete clusterings from the bubble topology of the Planar Maximally Filtered Graph (PMFG).</p><p>This function assigns each vertex to a cluster based on the directed bubble hierarchy tree (DBHT) structure. It computes both a non-discrete cluster membership matrix and a discrete cluster assignment vector, using the converging bubbles identified in the directed bubble tree.</p><p><strong>Arguments</strong></p><ul><li><code>Rpm::AbstractMatrix{&lt;:Real}</code>: <code>N×N</code> sparse weighted adjacency matrix of the PMFG.</li><li><code>Dpm::AbstractMatrix{&lt;:Real}</code>: <code>N×N</code> shortest path lengths matrix of the PMFG.</li><li><code>Hb::AbstractMatrix{&lt;:Real}</code>: Undirected bubble tree of the PMFG (from <a href="#PortfolioOptimisers.BubbleHierarchy"><code>BubbleHierarchy</code></a>).</li><li><code>Mb::AbstractMatrix{&lt;:Real}</code>: <code>Nc×Nb</code> bubble membership matrix for 3-cliques. <code>Mb[n, bi] = 1</code> indicates 3-clique <code>n</code> belongs to bubble <code>bi</code>.</li><li><code>Mv::AbstractMatrix{&lt;:Real}</code>: <code>N×Nb</code> bubble membership matrix for vertices. <code>Mv[n, bi] = 1</code> means vertex <code>n</code> is a vertex of bubble <code>bi</code>.</li><li><code>CliqList::AbstractMatrix{&lt;:Real}</code>: <code>Nc×3</code> matrix. Each row lists the three vertices of a 3-clique in the MPG.</li></ul><p><strong>Details</strong></p><ul><li>The function first computes the directed bubble hierarchy tree using <a href="#PortfolioOptimisers.DirectHb"><code>DirectHb</code></a>.</li><li>Converging bubbles are identified as cluster centers.</li><li>Non-discrete cluster membership (<code>Adjv</code>) is determined by traversing the directed bubble tree from each converging bubble.</li><li>Discrete cluster assignments (<code>Tc</code>) are made by resolving overlaps and assigning each vertex to the most strongly associated converging bubble, or, if ambiguous, to the closest converging bubble by shortest path.</li><li>Used internally by DBHT clustering and for extracting cluster assignments from the PMFG bubble structure.</li></ul><p><strong>Returns</strong></p><ul><li><code>Adjv::SparseMatrixCSC{Int, Int}</code>: <code>N×Nk</code> cluster membership matrix for vertices for non-discrete clustering via the bubble topology. <code>Adjv[n, k] = 1</code> indicates cluster membership of vertex <code>n</code> to the <code>k</code>&#39;th non-discrete cluster.</li><li><code>Tc::Vector{Int}</code>: <code>N×1</code> cluster membership vector. <code>Tc[n] = k</code> indicates cluster membership of vertex <code>n</code> to the <code>k</code>&#39;th discrete cluster.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.DirectHb"><code>DirectHb</code></a></li><li><a href="#PortfolioOptimisers.BubbleHierarchy"><code>BubbleHierarchy</code></a></li><li><a href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>CliqHierarchyTree2s</code></a></li><li><a href="#PortfolioOptimisers.DBHT"><code>DBHT</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L1156-L1195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.BubbleMember" href="#PortfolioOptimisers.BubbleMember"><code>PortfolioOptimisers.BubbleMember</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BubbleMember(Rpm::AbstractMatrix{&lt;:Real}, Mv::AbstractMatrix{&lt;:Real},
             Mc::AbstractMatrix{&lt;:Real})</code></pre><p>Assign each vertex to a specific bubble in the bubble hierarchy.</p><p>This function determines the bubble membership of each vertex, resolving ambiguities when a vertex could belong to multiple bubbles. Assignment is based on the strength of connections (edge weights) between the vertex and each candidate bubble.</p><p><strong>Arguments</strong></p><ul><li><code>Rpm</code>: <code>N×N</code> sparse weighted adjacency matrix of the PMFG.</li><li><code>Mv</code>: <code>N×Nb</code> bubble membership matrix for vertices. <code>Mv[n, bi] = 1</code> means vertex <code>n</code> is a vertex of bubble <code>bi</code>.</li><li><code>Mc</code>: Matrix indicating bubbles that coincide with clusters.</li></ul><p><strong>Details</strong></p><ul><li>Vertices belonging to a single bubble are assigned directly.</li><li>For vertices that could belong to multiple bubbles, assignment is made to the bubble with the strongest normalized connection (fraction of edge weights).</li><li>Used internally for intra- and inter-cluster hierarchy construction in DBHT clustering.</li></ul><p><strong>Returns</strong></p><ul><li><code>Mvv::Matrix{Int}</code>: <code>N×Nb</code> matrix where <code>Mvv[n, bi] = 1</code> if vertex <code>n</code> is assigned to bubble <code>bi</code>.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.HierarchyConstruct4s"><code>HierarchyConstruct4s</code></a></li><li><a href="#PortfolioOptimisers.BubbleHierarchy"><code>BubbleHierarchy</code></a></li><li><a href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>CliqHierarchyTree2s</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L1251-L1282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.DendroConstruct" href="#PortfolioOptimisers.DendroConstruct"><code>PortfolioOptimisers.DendroConstruct</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DendroConstruct(Zi::AbstractMatrix{&lt;:Real}, LabelVec1::AbstractVector{&lt;:Real},
                LabelVec2::AbstractVector{&lt;:Real},
                LinkageDist::Union{&lt;:Real, &lt;:AbstractVector{&lt;:Real}})</code></pre><p>Construct the linkage matrix by continually adding rows to the matrix.</p><p>This function appends a new row to the linkage matrix at each iteration, recording the merge of clusters as indicated by changes in the label vectors. It is used internally for building dendrograms in DBHT and related hierarchical clustering routines.</p><p><strong>Inputs</strong></p><ul><li><code>Zi</code>: Linkage matrix at iteration <code>i</code> in the same format as the output from Matlab.</li><li><code>LabelVec1</code>: Label vector for the vertices in the bubble for the previous valid iteration.</li><li><code>LabelVec2</code>: Label vector for the vertices in the bubble for the trial iteration.</li><li><code>LinkageDist</code>: Linkage distance(s) for the current merge.</li></ul><p><strong>Details</strong></p><ul><li>The function identifies which clusters have changed between <code>LabelVec1</code> and <code>LabelVec2</code> and appends a new row to the linkage matrix for the merge.</li><li>The linkage matrix <code>Z</code> can be converted to a format compatible with <a href="https://juliastats.org/Clustering.jl/stable/hclust.html#Clustering.Hclust"><code>Clustering.Hclust</code></a> using <a href="#PortfolioOptimisers.turn_into_Hclust_merges"><code>turn_into_Hclust_merges</code></a>.</li><li>Used internally by <a href="#PortfolioOptimisers.HierarchyConstruct4s"><code>HierarchyConstruct4s</code></a> and related routines for DBHT dendrogram construction.</li></ul><p><strong>Returns</strong></p><ul><li><code>Z::AbstractMatrix{&lt;:Real}</code>: Linkage matrix at iteration <code>i + 1</code> in the same format as the output from Matlab.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.HierarchyConstruct4s"><code>HierarchyConstruct4s</code></a></li><li><a href="#PortfolioOptimisers.turn_into_Hclust_merges"><code>turn_into_Hclust_merges</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L1304-L1336">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.LinkageFunction" href="#PortfolioOptimisers.LinkageFunction"><code>PortfolioOptimisers.LinkageFunction</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinkageFunction(d::AbstractMatrix{&lt;:Real}, labelvec::AbstractVector{&lt;:Real})</code></pre><p>Find the pair of clusters with the best linkage in a bubble.</p><p>This function searches for the pair of clusters (as indicated by <code>labelvec</code>) with the strongest linkage according to the provided distance matrix <code>d</code>. The best linkage is defined as the pair with the maximum inter-cluster distance among all pairs of clusters in the bubble. Used internally for hierarchical linkage construction in DBHT dendrogram routines.</p><p><strong>Inputs</strong></p><ul><li><code>d</code>: <code>Nv×Nv</code> distance matrix for the vertices assigned to a bubble.</li><li><code>labelvec</code>: Label vector for the vertices in the bubble.</li></ul><p><strong>Details</strong></p><ul><li>For each unique pair of cluster labels, the function computes the maximum distance between their members.</li><li>Returns the pair with the largest such distance and the corresponding value.</li><li>Used in <a href="#PortfolioOptimisers.build_link_and_dendro"><code>build_link_and_dendro</code></a> and <a href="#PortfolioOptimisers.HierarchyConstruct4s"><code>HierarchyConstruct4s</code></a> to determine which clusters to merge at each step.</li></ul><p><strong>Returns</strong></p><ul><li><code>PairLink::Vector{Int}</code>: Pair of cluster labels with the best linkage.</li><li><code>dvu::Real</code>: Value of the best linkage (maximum inter-cluster distance).</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.build_link_and_dendro"><code>build_link_and_dendro</code></a></li><li><a href="#PortfolioOptimisers.HierarchyConstruct4s"><code>HierarchyConstruct4s</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L1345-L1374">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.build_link_and_dendro" href="#PortfolioOptimisers.build_link_and_dendro"><code>PortfolioOptimisers.build_link_and_dendro</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_link_and_dendro(rg::AbstractRange, dpm::AbstractMatrix{&lt;:Real},
                      LabelVec::AbstractVector{&lt;:Real}, LabelVec1::AbstractVector{&lt;:Real},
                      LabelVec2::AbstractVector{&lt;:Real}, V::AbstractVector{&lt;:Real},
                      nc::Real, Z::AbstractMatrix{&lt;:Real})</code></pre><p>Iteratively construct the linkage matrix for a bubble or cluster.</p><p>This function iterates over the vertices in a bubble or cluster, merging the pair of clusters with the best linkage at each step (as determined by <a href="#PortfolioOptimisers.LinkageFunction"><code>LinkageFunction</code></a>), and appending the corresponding row to the linkage matrix using <a href="#PortfolioOptimisers.DendroConstruct"><code>DendroConstruct</code></a>. Used internally for building dendrograms in DBHT and related hierarchical clustering routines.</p><p><strong>Inputs</strong></p><ul><li><code>rg</code>: Range of indices for the vertices in the bubble or cluster.</li><li><code>dpm</code>: Distance matrix for the vertices assigned to the bubble or cluster.</li><li><code>LabelVec</code>: Current label vector for the clusters.</li><li><code>LabelVec1</code>: Label vector for the previous valid iteration.</li><li><code>LabelVec2</code>: Label vector for the trial iteration.</li><li><code>V</code>: Indices of the vertices in the bubble or cluster.</li><li><code>nc::Real</code>: Inverse of the linkage distance (or a counter for the merge steps).</li><li><code>Z</code>: Current linkage matrix.</li></ul><p><strong>Details</strong></p><ul><li>At each iteration, finds the pair of clusters with the best linkage using <a href="#PortfolioOptimisers.LinkageFunction"><code>LinkageFunction</code></a>.</li><li>Merges the pair by updating the label vector, and appends a new row to the linkage matrix using <a href="#PortfolioOptimisers.DendroConstruct"><code>DendroConstruct</code></a>.</li><li>Continues until all clusters in the range are merged.</li></ul><p><strong>Returns</strong></p><ul><li><code>Z::AbstractMatrix{&lt;:Real}</code>: Updated linkage matrix after all merges in the range.</li><li><code>nc::Real</code>: Updated inverse linkage distance or merge counter.</li><li><code>LabelVec1::AbstractVector{&lt;:Real}</code>: Updated label vector for the next iteration.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.LinkageFunction"><code>LinkageFunction</code></a></li><li><a href="#PortfolioOptimisers.DendroConstruct"><code>DendroConstruct</code></a></li><li><a href="#PortfolioOptimisers.HierarchyConstruct4s"><code>HierarchyConstruct4s</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L1398-L1438">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.HierarchyConstruct4s" href="#PortfolioOptimisers.HierarchyConstruct4s"><code>PortfolioOptimisers.HierarchyConstruct4s</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">HierarchyConstruct4s(Rpm::AbstractMatrix{&lt;:Real}, Dpm::AbstractMatrix{&lt;:Real},
                     Tc::AbstractVector{&lt;:Real}, Mv::AbstractMatrix{&lt;:Real})</code></pre><p>Constructs the intra- and inter-cluster hierarchy by utilizing the Bubble Hierarchy structure of a Maximal Planar Graph, specifically a Planar Maximally Filtered Graph (PMFG).</p><p>This function builds a hierarchical clustering (dendrogram) by first constructing intra-cluster linkages within each cluster (using the bubble structure), and then merging clusters to form the global hierarchy. It is a core step in the DBHT (Direct Bubble Hierarchical Tree) clustering pipeline.</p><p><strong>Inputs</strong></p><ul><li><code>Rpm</code>: <code>N×N</code> sparse weighted adjacency matrix of the PMFG.</li><li><code>Dpm</code>: <code>N×N</code> shortest path lengths matrix of the PMFG.</li><li><code>Tc</code>: <code>N×1</code> cluster membership vector. <code>Tc[n] = k</code> indicates cluster membership of vertex <code>n</code> to the <code>k</code>&#39;th discrete cluster.</li><li><code>Mv</code>: <code>N×Nb</code> bubble membership matrix. <code>Mv[n, bi] = 1</code> means vertex <code>n</code> is a vertex of bubble <code>bi</code>.</li></ul><p><strong>Details</strong></p><pre><code class="nohighlight hljs">- For each cluster, the function identifies the bubbles that coincide with the cluster and assigns each vertex to a specific bubble using [`BubbleMember`](@ref).
- It constructs intra-bubble and intra-cluster linkages using [`build_link_and_dendro`](@ref).
- After intra-cluster linkage, it merges clusters to form the global hierarchy using inter-cluster linkage steps.
- The resulting linkage matrix can be converted to a format compatible with [`Clustering.Hclust`](https://juliastats.org/Clustering.jl/stable/hclust.html#Clustering.Hclust) using [`turn_into_Hclust_merges`](@ref).
- Used internally by DBHT clustering routines for dendrogram construction.</code></pre><p><strong>Returns</strong></p><ul><li><code>Z::AbstractMatrix{&lt;:Real}</code>: <code>(N-1)×3</code> linkage matrix in the same format as the output from Matlab, suitable for conversion to <a href="https://juliastats.org/Clustering.jl/stable/hclust.html#Clustering.Hclust"><code>Clustering.Hclust</code></a>.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.BubbleMember"><code>BubbleMember</code></a></li><li><a href="#PortfolioOptimisers.build_link_and_dendro"><code>build_link_and_dendro</code></a></li><li><a href="#PortfolioOptimisers.turn_into_Hclust_merges"><code>turn_into_Hclust_merges</code></a></li><li><a href="#PortfolioOptimisers.DBHT"><code>DBHT</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L1456-L1491">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.turn_into_Hclust_merges" href="#PortfolioOptimisers.turn_into_Hclust_merges"><code>PortfolioOptimisers.turn_into_Hclust_merges</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">turn_into_Hclust_merges(Z::AbstractMatrix{&lt;:Real})</code></pre><p>Convert a Matlab-style linkage matrix to a format compatible with <a href="https://juliastats.org/Clustering.jl/stable/hclust.html#Clustering.Hclust"><code>Clustering.Hclust</code></a>.</p><p>This function transforms a linkage matrix produced by DBHT or similar hierarchical clustering routines into the format required by <a href="https://juliastats.org/Clustering.jl/stable/hclust.html#Clustering.Hclust"><code>Clustering.Hclust</code></a>, including proper indexing and cluster size tracking.</p><p><strong>Inputs</strong></p><ul><li><code>Z</code>: Matlab-style linkage matrix, where each row represents a merge step with cluster indices and linkage heights.</li></ul><p><strong>Details</strong></p><ul><li>For each merge, leaf indices are converted to negative values, and cluster sizes are accumulated in the fourth column.</li><li>Internal cluster indices are updated to reference the correct merged clusters.</li><li>The resulting matrix can be passed directly to <a href="https://juliastats.org/Clustering.jl/stable/hclust.html#Clustering.Hclust"><code>Clustering.Hclust</code></a> for dendrogram construction and further analysis.</li></ul><p><strong>Returns</strong></p><ul><li><code>Z::AbstractMatrix{&lt;:Real}</code>: Linkage matrix in <a href="https://juliastats.org/Clustering.jl/stable/hclust.html#Clustering.Hclust"><code>Clustering.Hclust</code></a> format, with updated indices and cluster sizes.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.HierarchyConstruct4s"><code>HierarchyConstruct4s</code></a></li><li><a href="#PortfolioOptimisers.DendroConstruct"><code>DendroConstruct</code></a></li><li><a href="https://juliastats.org/Clustering.jl/stable/hclust.html#Clustering.Hclust"><code>Clustering.Hclust</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L1546-L1574">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.DBHTs" href="#PortfolioOptimisers.DBHTs"><code>PortfolioOptimisers.DBHTs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DBHTs(D::AbstractMatrix{&lt;:Real}, S::AbstractMatrix{&lt;:Real}; branchorder::Symbol = :optimal,
      root::DBHTRootMethod = UniqueRoot())</code></pre><p>Perform Direct Bubble Hierarchical Tree clustering, a deterministic clustering algorithm [<a href="../092-reference/#DBHTs">1</a>]. This version uses a graph-theoretic filtering technique called Triangulated Maximally Filtered Graph (TMFG).</p><p>This function implements the full DBHT clustering pipeline: it constructs a Planar Maximally Filtered Graph (PMFG) from the similarity matrix, extracts the clique and bubble hierarchies, assigns clusters, and builds a hierarchical clustering (dendrogram) compatible with <a href="https://juliastats.org/Clustering.jl/stable/hclust.html#Clustering.Hclust"><code>Clustering.Hclust</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>D</code>: <code>N×N</code> dissimilarity matrix (e.g., a distance matrix). Must be symmetric and non-empty.</li><li><code>S</code>: <code>N×N</code> non-negative similarity matrix. Must be symmetric and non-empty.</li><li><code>branchorder</code>: Ordering method for the dendrogram branches. Accepts <code>:optimal</code>, <code>:barjoseph</code>, or <code>:r</code>.</li><li><code>root</code>: Root selection method for the clique hierarchy.</li></ul><p><strong>Validation</strong></p><ul><li><code>!isempty(D) &amp;&amp; issymmetric(D)</code>.</li><li><code>!isempty(S) &amp;&amp; issymmetric(S)</code>.</li><li><code>size(D) == size(S)</code>.</li></ul><p><strong>Details</strong></p><ul><li>Validates that <code>D</code> and <code>S</code> are non-empty, symmetric, and of equal size.</li><li>Constructs the PMFG using <a href="#PortfolioOptimisers.PMFG_T2s"><code>PMFG_T2s</code></a>.</li><li>Computes shortest path distances on the PMFG.</li><li>Extracts clique and bubble hierarchies using <a href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>CliqHierarchyTree2s</code></a> and <a href="#PortfolioOptimisers.BubbleHierarchy"><code>BubbleHierarchy</code></a>.</li><li>Assigns clusters using <a href="#PortfolioOptimisers.BubbleCluster8s"><code>BubbleCluster8s</code></a>.</li><li>Builds the hierarchical clustering using <a href="#PortfolioOptimisers.HierarchyConstruct4s"><code>HierarchyConstruct4s</code></a> and converts it to <a href="https://juliastats.org/Clustering.jl/stable/hclust.html#Clustering.Hclust"><code>Clustering.Hclust</code></a> format.</li><li>Supports different root selection strategies and dendrogram branch orderings.</li></ul><p><strong>Returns</strong></p><ul><li><code>T8::Vector{Int}</code>: <code>N×1</code> cluster membership vector.</li><li><code>Rpm::SparseMatrixCSC{&lt;:Real, Int}</code>: <code>N×N</code> adjacency matrix of the Planar Maximally Filtered Graph (PMFG).</li><li><code>Adjv::SparseMatrixCSC{Int, Int}</code>: Bubble cluster membership matrix from <a href="#PortfolioOptimisers.BubbleCluster8s"><code>BubbleCluster8s</code></a>.</li><li><code>Dpm::Matrix{&lt;:Real}</code>: <code>N×N</code> shortest path length matrix of the PMFG.</li><li><code>Mv::SparseMatrixCSC{Int, Int}</code>: <code>N×Nb</code> bubble membership matrix. <code>Mv[n, bi] = 1</code> means vertex <code>n</code> is a vertex of bubble <code>bi</code>.</li><li><code>Z::Matrix{&lt;:Real}</code>: <code>(N-1)×3</code> linkage matrix in Matlab format.</li><li><code>Z_hclust::Clustering.Hclust</code>: Dendrogram in <a href="https://juliastats.org/Clustering.jl/stable/hclust.html#Clustering.Hclust"><code>Clustering.Hclust</code></a> format.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.DBHT"><code>DBHT</code></a></li><li><a href="#PortfolioOptimisers.CliqHierarchyTree2s"><code>CliqHierarchyTree2s</code></a></li><li><a href="#PortfolioOptimisers.BubbleCluster8s"><code>BubbleCluster8s</code></a></li><li><a href="#PortfolioOptimisers.HierarchyConstruct4s"><code>HierarchyConstruct4s</code></a></li><li><a href="#PortfolioOptimisers.turn_into_Hclust_merges"><code>turn_into_Hclust_merges</code></a></li><li><a href="https://juliastats.org/Clustering.jl/stable/hclust.html#Clustering.Hclust"><code>Clustering.Hclust</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L1614-L1665">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.jlogo!" href="#PortfolioOptimisers.jlogo!"><code>PortfolioOptimisers.jlogo!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jlogo!(jlogo::AbstractMatrix, sigma::AbstractMatrix, source::AbstractMatrix, sign::Integer)</code></pre><p>Efficiently accumulate contributions to the sparse inverse covariance matrix for LoGo/DBHT.</p><p>This internal function updates the <code>jlogo</code> matrix in-place by iterating over a list of cliques or separators (<code>source</code>), extracting the corresponding submatrix from the covariance matrix <code>sigma</code>, inverting it, and adding (or subtracting) the result to the appropriate block in <code>jlogo</code>, scaled by <code>sign</code>.</p><p><strong>Arguments</strong></p><ul><li><code>jlogo</code>: The matrix to be updated in-place.</li><li><code>sigma</code>: The full covariance matrix.</li><li><code>source</code>: Each row contains indices of a clique or separator (e.g., 4-cliques or 3-cliques).</li><li><code>sign</code>: +1 for cliques, -1 for separators.</li></ul><p><strong>Details</strong></p><ul><li>For each row in <code>source</code>, the function extracts the submatrix of <code>sigma</code> corresponding to the clique/separator.</li><li>The inverse of this submatrix is computed and added to (or subtracted from) the corresponding block in <code>jlogo</code>.</li><li>Used internally by <a href="#PortfolioOptimisers.J_LoGo"><code>J_LoGo</code></a> to efficiently compute the sparse inverse covariance matrix for LoGo/DBHT.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>, updates <code>jlogo</code> in-place.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.J_LoGo"><code>J_LoGo</code></a></li><li><a href="#PortfolioOptimisers.LoGo"><code>LoGo</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L1711-L1741">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.J_LoGo" href="#PortfolioOptimisers.J_LoGo"><code>PortfolioOptimisers.J_LoGo</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">J_LoGo(sigma::AbstractMatrix, separators::AbstractMatrix, cliques::AbstractMatrix)</code></pre><p>Compute the sparse inverse covariance matrix using the LoGo (Local-Global) algorithm [<a href="../092-reference/#J_LoGo">2</a>].</p><p>This function implements the LoGo sparse inverse covariance estimation by combining clique and separator contributions from a Planar Maximally Filtered Graph (PMFG) or similar clique tree structure. It efficiently accumulates the inverses of covariance submatrices corresponding to cliques and separators, producing a sparse precision (inverse covariance) matrix suitable for robust portfolio optimization and risk management.</p><p><strong>Arguments</strong></p><ul><li><code>sigma</code>: The covariance matrix (<code>N×N</code>).</li><li><code>separators</code>: Each row contains indices of a separator (typically 3-cliques).</li><li><code>cliques</code>: Each row contains indices of a clique (typically 4-cliques).</li></ul><p><strong>Details</strong></p><ul><li>For each clique, the inverse of the corresponding submatrix of <code>sigma</code> is added to the output.</li><li>For each separator, the inverse of the corresponding submatrix is subtracted.</li><li>The resulting matrix is the sparse inverse covariance estimate, as described in the LoGo methodology.</li><li>Used internally by <a href="#PortfolioOptimisers.LoGo"><code>LoGo</code></a> and related estimators.</li></ul><p><strong>Returns</strong></p><ul><li><code>jlogo::Matrix{&lt;:Real}</code>: The LoGo sparse inverse covariance matrix.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.jlogo!"><code>jlogo!</code></a></li><li><a href="#PortfolioOptimisers.LoGo"><code>LoGo</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L1774-L1804">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.LoGo_dist_assert" href="#PortfolioOptimisers.LoGo_dist_assert"><code>PortfolioOptimisers.LoGo_dist_assert</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LoGo_dist_assert(dist::AbstractDistanceEstimator, sigma::AbstractMatrix, X::AbstractMatrix)</code></pre><p>Validate compatibility of the distance estimator and covariance matrix for LoGo sparse inverse covariance estimation by checking <code>size(sigma, 1) == size(X, 2)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>dist</code>: Distance estimator, typically a subtype of <code>AbstractDistanceEstimator</code>.</li><li><code>sigma</code>: Covariance matrix (<code>N×N</code>).</li><li><code>X</code>: Data matrix (<code>T×N</code> or <code>N×T</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>. Throws an error if validation fails.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.LoGo"><code>LoGo</code></a></li><li><a href="#PortfolioOptimisers.logo!"><code>logo!</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L1987-L2008">source</a></section><section><div><pre><code class="language-julia hljs">LoGo_dist_assert(args...)</code></pre><p>No-op fallback for other distance estimators.</p><p><strong>Returns</strong></p><ul><li><code>nothing</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L2020-L2030">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.logo!" href="#PortfolioOptimisers.logo!"><code>PortfolioOptimisers.logo!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">logo!(je::LoGo, pdm::Union{Nothing, &lt;:Posdef}, sigma::AbstractMatrix, X::AbstractMatrix;
      dims::Int = 1, kwargs...)</code></pre><p>Compute the LoGo (Local-Global) covariance matrix and update <code>sigma</code> in-place.</p><p>This method implements the LoGo algorithm for sparse inverse covariance estimation using the Planar Maximally Filtered Graph (PMFG) and clique-based decomposition. It validates inputs, computes the similarity and distance matrices, constructs the PMFG, identifies cliques and separators, and updates the input covariance matrix <code>sigma</code> in-place by inverting the LoGo sparse inverse covariance estimate. The result is projected to the nearest positive definite matrix if a <code>Posdef</code> estimator is provided.</p><p><strong>Arguments</strong></p><ul><li><code>je</code>: LoGo algorithm instance.</li><li><code>pdm</code>: Optional positive definite matrix estimator.</li><li><code>sigma</code>: Covariance matrix (<code>N×N</code>), updated in-place with the LoGo sparse inverse covariance.</li><li><code>X</code>: Data matrix (<code>T×N</code>).</li><li><code>dims</code>: Dimension along which to compute statistics (<code>1</code> for columns/assets, <code>2</code> for rows). Default: <code>1</code>.</li><li><code>kwargs...</code>: Additional keyword arguments passed to distance and similarity estimators.</li></ul><p><strong>Details</strong></p><ul><li>If <code>rho</code> is a covariance matrix, it is converted to a correlation matrix using <code>StatsBase.cov2cor</code>.</li><li>Computes the distance matrix using the configured distance estimator.</li><li>Computes the similarity matrix using the configured similarity algorithm.</li><li>Constructs the PMFG and extracts cliques and separators.</li><li>Computes the LoGo sparse inverse covariance matrix via <a href="#PortfolioOptimisers.J_LoGo"><code>J_LoGo</code></a>.</li><li>Updates <code>sigma</code> in-place with the inverse of the LoGo estimate.</li><li>Projects the result to the nearest positive definite matrix if <code>pdm</code> is provided.</li></ul><p><strong>Validation</strong></p><pre><code class="nohighlight hljs">- `size(sigma, 1) == size(sigma, 2)`.
- `size(sigma, 1) == size(X, 2)`.</code></pre><p><strong>Returns</strong></p><ul><li><code>nothing</code>. The input <code>sigma</code> is updated in-place.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.LoGo"><code>LoGo</code></a></li><li><a href="#PortfolioOptimisers.J_LoGo"><code>J_LoGo</code></a></li><li><a href="#PortfolioOptimisers.LoGo_dist_assert"><code>LoGo_dist_assert</code></a></li><li><a href="#PortfolioOptimisers.PMFG_T2s"><code>PMFG_T2s</code></a></li><li><a href="#PortfolioOptimisers.dbht_similarity"><code>dbht_similarity</code></a></li><li><a href="../003-PosdefMatrix/#PortfolioOptimisers.Posdef"><code>Posdef</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L2035-L2081">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PortfolioOptimisers.matrix_processing_algorithm!-Tuple{LoGo, Union{Nothing, Posdef}, AbstractMatrix, AbstractMatrix}" href="#PortfolioOptimisers.matrix_processing_algorithm!-Tuple{LoGo, Union{Nothing, Posdef}, AbstractMatrix, AbstractMatrix}"><code>PortfolioOptimisers.matrix_processing_algorithm!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matrix_processing_algorithm!(je::LoGo, pdm::Union{Nothing, &lt;:Posdef}, sigma::AbstractMatrix,
                             X::AbstractMatrix; dims::Int = 1, kwargs...)</code></pre><p>Apply the LoGo (Local-Global) transformation in-place to the covariance matrix as a matrix processing algorithm to.</p><p>This method provides a standard interface for applying the LoGo algorithm to a covariance matrix within the matrix processing pipeline of PortfolioOptimisers.jl. It validates inputs, computes the LoGo sparse inverse covariance matrix, and updates <code>sigma</code> in-place. If a positive definite matrix estimator (<code>pdm</code>) is provided, the result is projected to the nearest positive definite matrix.</p><p><strong>Arguments</strong></p><ul><li><code>je</code>: LoGo algorithm instance (<code>LoGo</code>).</li><li><code>pdm</code>: Optional positive definite matrix estimator (e.g., <code>Posdef()</code>), or <code>nothing</code>.</li><li><code>sigma</code>: Covariance matrix (<code>N×N</code>), updated in-place.</li><li><code>X</code>: Data matrix (<code>T×N</code> or <code>N×T</code>).</li><li><code>dims</code>: Dimension along which to compute statistics (<code>1</code> for columns/assets, <code>2</code> for rows). Default: <code>1</code>.</li><li><code>kwargs...</code>: Additional keyword arguments passed to distance and similarity estimators.</li></ul><p><strong>Details</strong></p><ul><li>Internally, it calls <a href="#PortfolioOptimisers.logo!"><code>logo!</code></a> to perform the LoGo sparse inverse covariance estimation and update <code>sigma</code> in-place.</li><li>Used in composable workflows for covariance matrix estimation.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>. The input <code>sigma</code> is updated in-place.</li></ul><p><strong>Related</strong></p><ul><li><a href="#PortfolioOptimisers.LoGo"><code>LoGo</code></a></li><li><a href="#PortfolioOptimisers.logo!"><code>logo!</code></a></li><li><a href="../003-PosdefMatrix/#PortfolioOptimisers.Posdef"><code>Posdef</code></a></li><li><a href="../006-MatrixProcessing/#PortfolioOptimisers.AbstractMatrixProcessingAlgorithm"><code>AbstractMatrixProcessingAlgorithm</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/dcelisgarza/PortfolioOptimisers.jl/blob/660c2baeb23a8b2992fb82c82bcbe6da2e5837d0/src/11_Phylogeny/4_DBHT.jl#L2102-L2136">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../011-3-Phylogeny/">« Hierarchical</a><a class="docs-footer-nextpage" href="../011-5-Phylogeny/">Phylogeny »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 19 September 2025 23:03">Friday 19 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
